"""PruebaTYK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ll-H4EShfh0HlPLG-RqjTGbeZUlyDe6F
"""

!pip install pyvis
import networkx as nx
import plotly.graph_objs as go
from pyvis.network import Network
import os, re, json, csv, uuid, glob, io
from pathlib import Path
import tempfile
from IPython.display import display, HTML, clear_output

import matplotlib.pyplot as plt
import plotly.io as pio

from typing import Any, Dict, List, Optional, Tuple, Iterable,Union, Sequence, Set
import heapq
from collections import defaultdict
from matplotlib import cm, colormaps, colors as mcolors
import webbrowser
!pip install pycountry
import pandas as pd

PATH= "data/HVOA/"

"""## **Instanciando la clase `TyK`**

Antes de empezar a analizar y visualizar datos, necesitamos **crear nuestra herramienta de trabajo**: la clase `TyK`. Será nuestro tablero de control que usaremos durante todo el análisis.

---

### **¿Qué hace este paso?**
- **Carga** la información de clusters y subclusters desde varios archivos.
- **Guarda** estos datos en memoria para poder explorarlos y graficarlos.
- **Conecta** los nombres de los clusters con sus identificadores numéricos.

---


### **¿Qué debo modificar?**
- Solo el valor de **`PATH`**, que indica la **carpeta donde están guardados los archivos**.  
  Si los archivos están en otra ubicación, se ajusta esta ruta.



"""
from tyk import TyK
tyk = TyK(
    path_base=PATH, #ESTO ES LO UNICO QUE HAY QUE MODIFICAR
)


# contar cuántos items hay por stuff en cada TOP
for cid, name in tyk.list_clusters(top=True, show=None):
    c = tyk.get_cluster(cid)
    stuff = (c.get("stuff") or {})
    counts = {k: len(v or []) for k, v in stuff.items()}
    print(f"{cid} — {name}:", counts)

import pandas as pd

stuff_types = ["MCP","MRP","MCAU","K","TK","S","S2","J","C","I","R","RJ","A","Y"]
rows = []

for cid, name in tyk.list_clusters(top=True, show=None):   # top=False para SUB

    c = tyk.get_cluster(cid)
    s = (c.get("stuff") or {})
    row = {"id": cid, "name": name, "size": int(c.get("size", 0))}
    for t in stuff_types:
        row[t] = len(s.get(t, []) or [])
    rows.append(row)

df = pd.DataFrame(rows).set_index(["id","name"]).sort_values("MCP", ascending=False)
df

# @title
tyk.plot_map()

tyk.plot_countries_map_global(colorscale="Turbo")

"""Mostrar todos los clusters o subclusters:"""

# @title Mostrar todos los clusters o subclusters
#{"run":"auto"}
level = "TOP"            # @param ["TOP","SUB"]
if level == "TOP":
  tyk.list_clusters()
else:
  tyk.list_clusters(top=False)

"""Mostrar los subclusters de un cluster"""

# @title Mostrar los subclusters de un cluster
top_cluster = "10"  # @param {"type":"string"}
tyk.list_subclusters(top_cluster)

"""## **Visualización de la red de co-ocurrencia**

En este paso vamos a generar un **grafo** que muestra cómo se relacionan entre sí los elementos de un tipo específico (por ejemplo, palabras clave, revistas o autores).

---

### **¿Qué hace este paso?**
- **Filtra** los nodos de la red según el tipo indicado (`node_type`).
- **Elimina** nodos muy pequeños para simplificar la visualización (`min_node_size`).
- **Construye** un grafo en el que:
  - Cada nodo representa un elemento (ej. palabra clave).
  - Cada arista representa la co-ocurrencia con otro elemento.

---

### **Parámetros utilizados**
- **`node_type="K"`** → Visualiza palabras clave (*Keywords*).
  - `"K"` → Palabras clave.
  - `"TK"` → Palabras del título.
  - `"S"` → Categorías temáticas.
  - `"S2"` → "Subject Sub-Categories"
  - `"I"` → "Institutions"
  - `"R"` → "References"
  - `"RJ"` → "Reference Sources"
- **`min_node_size=5`** → Muestra solo elementos con al menos 5 ocurrencias.

---

"""

# @title {"run":"auto"}
node_type = "K"  # @param ["K","TK","S","S2","I","R","RJ"]
max_nodes = 250 # @param {"type": "string"}
tyk.plot_cooc_network_interactive(node_type=node_type, min_node_size=5, max_nodes= max_nodes);

"""## **Visualización del grafo de clusters principales (TOP)**

Muestra un **mapa de relaciones** entre los clusters principales (*TOP*)

---

### **¿Qué hace este paso?**
- **Construye** un grafo donde:
  - Cada nodo es un cluster principal.
  - Las aristas representan conexiones o relaciones entre clusters.
- **Ajusta** el tamaño de los nodos en función de su importancia o tamaño.

---

### **Parámetros utilizados**
- **`layout="circular"`** → Organiza los nodos en un círculo, útil para obtener una vista equilibrada y simétrica de la red.

"""

tyk.plot_clusters_graph_interactive()

"""## **Visualización interactiva de subclusters por TOP**

Esta función permite **explorar gráficamente** todos los subclusters que pertenecen a un cluster principal (**TOP**) específico.  
Es útil para identificar la estructura interna de un TOP y las relaciones entre sus subclusters.

---

### **Instrucciones de uso**
1. **Selecciona** el TOP que deseas analizar:
   - Puedes ingresar **el ID** del TOP (ej: `1`).
   - O **su nombre** exacto tal como aparece en la lista (ej: `"EMPATHY"`).
2. El grafo resultante mostrará:
   - **Nodos** → Cada subcluster del TOP seleccionado.
   - **Conexiones** → Relaciones detectadas entre subclusters.
3. Si no indicas ningún TOP:
   - Se mostrará una **lista de todos los TOPs** disponibles para que elijas.

"""

# @title {"run":"auto"}
top_cluster = "5"  # @param {"type":"string"}
tyk.plot_subclusters_graph_interactive(top_cluster)

"""## **Renombrar un cluster (TOP o SUB)**

Con este comando puedes cambiar el nombre de cualquier **TOP** o **SUB** cluster de forma inmediata.  
Este cambio se aplicará a todas las visualizaciones, tablas y listados, pero **no modifica los archivos originales** en disco.
1. **Selecciona** si es un TOP o SUB cluster.
2. **Indica** el cluster que deseas modificar:
   - Puedes ingresar **el ID** del TOP (ej: `1`).
   - O **su nombre** exacto tal como aparece en la lista (ej: `"EMPATHY"`).
3. Ingresa el **nuevo nombre** del cluster indicado previamente.


"""

# @title {"run":"auto"}
level = "SUB"            # @param ["TOP","SUB"]
cluster = "10"  # @param {"type":"string"}
nuevo_nombre = "PERFORMANCes"  # @param {"type":"string"}

tyk.rename_cluster(level=level, cluster=cluster, new_name=nuevo_nombre)

"""## **Exploración detallada de un cluster o subcluster**

Esta es la función más importante para **examinar en profundidad** la información de un cluster específico, ya sea un **TOP** o un **SUB**.  
Permite visualizar gráficos, tablas y métricas asociadas al tipo de información seleccionado.

---

### **Parámetros principales**
- **`level`** → Nivel de análisis:
  - `"TOP"` → Examina un cluster principal.
  - `"SUB"` → Examina un subcluster que pertenece a un TOP.
- **`cluster_top`** → ID o nombre del TOP que se quiere explorar.
- **`cluster_sub`** → ID o nombre del subcluster (solo si `level="SUB"`).


### **Comportamiento**
- **Si `level="TOP"`**:
  - Sin `cluster_top` → Lista los TOP disponibles.
  - Con `cluster_top` → Muestra figura o tabla del TOP.
- **Si `level="SUB"`**:
  - Requiere `cluster_top`.
  - Sin `cluster_sub` → Lista los subclusters del TOP elegido.
  - Con `cluster_sub` → Muestra figura o tabla del SUB, indicando también a qué TOP pertenece.

---

### **Visualización**
- Muestra siempre un **encabezado descriptivo** con:
  - Nivel.
  - Nombre y ID del cluster.
  - Tipo de información seleccionada.
- El contenido mostrado dependerá del `stuff_type` elegido: puede ser un **gráfico interactivo** o una **tabla con enlaces**.

"""

# @title {"run":"auto"}
cluster_top = "1"        # @param {"type":"string"}
stuff_type = "MRP"         # @param ["K","TK","S","S2","J","C","I","R","RJ","A","MCAU","MCP","MRP","Y"]
tyk.describe_cluster_params("TOP", stuff_type, cluster_top, "")

# @title {"run":"auto"}
cluster_top = "1"        # @param {"type":"string"}
cluster_sub = "1000"         # @param {"type":"string"}
stuff_type = "TK"         # @param ["K","TK","S","S2","J","C","I","R","RJ","A","MCAU","MCP","MRP","Y"]
tyk.describe_cluster_params("SUB", stuff_type, cluster_top, cluster_sub)

#MOSTRAR SIEMPRE SUBCLUSTERS
