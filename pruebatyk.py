# -*- coding: utf-8 -*-
"""PruebaTYK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ll-H4EShfh0HlPLG-RqjTGbeZUlyDe6F
"""

from google.colab import drive
drive.mount('/content/drive/')

import os
#/content/drive/MyDrive/Drive/Mauri_AR
PATH= "/content/drive/MyDrive/Drive/Mauri_AR"
#print(os.listdir("/content/drive/MyDrive/tyk/"))

!pip install pyvis
import networkx as nx
import plotly.graph_objs as go
from pyvis.network import Network
import os, re, json, csv, uuid, glob, io
from pathlib import Path
import tempfile
from IPython.display import display, HTML, clear_output

import matplotlib.pyplot as plt
import plotly.io as pio

from typing import Any, Dict, List, Optional, Tuple, Iterable,Union, Sequence, Set
import heapq
from collections import defaultdict
from matplotlib import cm, colormaps, colors as mcolors
import webbrowser
!pip install pycountry
import pandas as pd

# @title Class Tyk
class TyK:
    def __init__(
        self,
        path_base: str,
        dat_folder: Optional[str] = None,
        json_bcclusters="jsonfiles/BCclusters.json",
        tex_top_clusters=None,
        tex_sub_clusters=None,
        gdf_clusters=None,

        # tex_top_clusters="texfiles/top_clusters.tex",
        # tex_sub_clusters="texfiles/subtop_clusters.tex",
        # gdf_clusters="gdffiles/BCclusters.gdf",

        json_cooc="freqs/coocnetworks.json",
    ):
        # Rutas absolutas / auto-detect con patrones
        self.path_base = path_base
        self.json_bcclusters = self._resolve_path(
            json_bcclusters, default_dir="jsonfiles",
            patterns=["*BCclusters*.json"], preferred_basename="BCclusters.json"
        )
        self.tex_top_clusters = self._resolve_path(
            tex_top_clusters, default_dir="texfiles",
            patterns=["*top_clusters*.tex"], preferred_basename="top_clusters.tex"
        )
        self.tex_sub_clusters = self._resolve_path(
            tex_sub_clusters, default_dir="texfiles",
            patterns=["*subtop_clusters*.tex"], preferred_basename="subtop_clusters.tex"
        )
        self.gdf_clusters = self._resolve_path(
            gdf_clusters, default_dir="gdffiles",
            patterns=["*BCclusters*.gdf", "*BCnetwork*.gdf"], preferred_basename="BCclusters.gdf"
        )
        self.json_cooc = self._resolve_path(
            json_cooc, default_dir="freqs",
            patterns=["*coocnetworks*.json"], preferred_basename="coocnetworks.json"
        )

        self.dat_folder = os.path.join(path_base, dat_folder) if dat_folder else None


        # Estructuras en memoria
        # --- TEX labels ---
        self.label_map_top: Dict[str, str] = {}            # "1" -> "EMPATHY"
        self.label_map_sub: Dict[str, str] = {}            # "1004" -> "PHILOSOPHY"
        self.cluster_name_to_id: Dict[str, str] = {}       # "EMPATHY" -> "1"
        self.subcluster_name_to_id: Dict[str, str] = {}    # "PHILOSOPHY" -> "1004"
        self.cluster_names: List[str] = []                 # nombres TOP
        self.subcluster_names: List[str] = []              # nombres SUB
        self.subclusters_by_top: Dict[str, List[str]] = {} # "1" -> ["1001","1002",...] se usa para listar y validar subclusters según TOP.

        # --- JSON BCclusters ---
        self.bc_clusters: Dict[str, Any] = {}
        self.cluster_dict: Dict[str, Dict[str, Any]] = {}  # "1" o "1004" -> dict completo para describe_cluster_params y _build_figure

        # --- JSON cooc ---
        self.cooc_data: Dict[str, Any] = {}

        # --- GDF ---
        self.gdf_nodes_top, self.gdf_nodes_sub = [], []
        self.gdf_edges_top, self.gdf_edges_sub = [], []


        # --- Grafos cache ---
        self.G_clusters_top: Optional[nx.Graph] = None
        self.G_sub_by_top: Dict[str, nx.Graph] = {}

        self.verbose_notify: bool = True # mostrar avisos HTML en fallbacks/casos comunes
        self.removed_clusters: Set[str] = set()
        # Títulos para stuff
        self.stuff_titles: Dict[str, str] = {
            "K": "Keywords",
            "TK": "Title Words",
            "S": "Subject Categories",
            "S2": "Subject Sub-Categories",
            "J": "Journal Sources",
            "C": "Countries",
            "I": "Institutions",
            "R": "References",
            "RJ": "Reference Sources",
            "A": "Authors (Freq)",
            "MCAU": "Most Cited Authors",
            "MCP": "Most Cited Papers",
            "MRP": "Most Representative Papers",
            "Y": "Publicaciones por año",
        }
        self.countries_global_df = None  # DF global de países (articles, frequency)
        self.cluster_summaries: Dict[str, str] = {}  # id -> HTML del resumen (top y sub)


        # =========== CARGA INICIAL ===========
        self._load_labels()            # parsea .tex si existen (puede quedar vacío)
        self._load_bcclusters_json()   # carga nodos y rellena label_real; infiere nombres si falta .tex

        self._load_cooc_json()
        self._load_gdf_clusters()
        self._index_subclusters_by_top()   # Relacionar subclusters con su top
        self._ensure_graph_from_json()
        self.countries_global_df = self._read_freq_dat(f"{path_base}freqs/freq_countries.dat")  # precalcula distribución global
        self.load_cluster_summaries(f"{path_base}clusters") #, filename="extended_bulleted_mcp.txt"


    # ------------------------ CARGA / PARSE ------------------------
    def _read_freq_dat(self, path: str) -> pd.DataFrame:
        """
        Lee un freq_countries.dat con cabeceras tipo:
        'Ranking Item Cantidad Frecuencia'
        Maneja repeticiones de encabezado y separadores irregulares.
        """
        with open(path, "r", encoding="utf-8-sig", errors="ignore") as f:
            raw = f.read()

        # Hay .dat que repiten el bloque "Ranking Item Cantidad Frecuencia"
        # y/o usan espacios variables. Normalizamos a CSV temporal.
        lines = []
        for line in raw.splitlines():
            line = line.strip()
            if not line:
                continue
            # Skip headers disfrazados o numeraciones
            if line.lower().startswith("ranking item") or line.lower().startswith("ranking, item"):
                continue
            # Separar por múltiples espacios o tab o coma
            parts = re.split(r"\s{2,}|\t|,", line)
            parts = [p.strip() for p in parts if p.strip() != ""]
            # Esperamos 4 columnas: Ranking, Item, Cantidad, Frecuencia
            if len(parts) == 4 and parts[0].isdigit():
                lines.append(parts)
            # Si ya viene sin ranking (3 cols), también lo aceptamos
            elif len(parts) == 3 and not parts[0].isdigit():
                # Item, Cantidad, Frecuencia
                lines.append(["", parts[0], parts[1], parts[2]])

        if not lines:
            raise ValueError("No pude parsear el freq_countries.dat")

        tmp = io.StringIO()
        tmp.write("ranking,item,cantidad,frecuencia\n")
        for row in lines:
            r, it, cant, freq = row
            tmp.write(f"{r},{it},{cant},{freq}\n")
        tmp.seek(0)

        df = pd.read_csv(tmp)
        # Limpieza y tipos
        df["item"] = df["item"].astype(str).str.strip()
        df["cantidad"] = pd.to_numeric(df["cantidad"], errors="coerce").fillna(0).astype(int)
        df["frecuencia"] = pd.to_numeric(df["frecuencia"], errors="coerce").fillna(0.0)

        # Ordenar por cantidad desc, luego frecuencia
        df = df.sort_values(["cantidad", "frecuencia"], ascending=[False, False]).reset_index(drop=True)

        # Renombrar al esquema estándar
        df = df.rename(columns={"item": "country", "cantidad": "articles", "frecuencia": "frequency"})
        return df[["country", "articles", "frequency"]]
    def _display_label(self, cid: str) -> str:
        cid = str(cid)
        rec = self.cluster_dict.get(cid, {}) or {}
        level = int(rec.get("level", 1) or 1)

        if level == 0:
            lab = self.label_map_top.get(cid)
        else:
            lab = self.label_map_sub.get(cid)

        lab = lab or rec.get("label_real") or rec.get("label") or cid
        return str(lab)

    def _refresh_label_indexes(self) -> None:
        """Reconstruye mapeos inversos y listas de nombres a partir de label_map_*."""
        self.cluster_name_to_id = {v: k for k, v in self.label_map_top.items() if v}
        self.subcluster_name_to_id = {v: k for k, v in self.label_map_sub.items() if v}
        self.cluster_names = list(self.cluster_name_to_id.keys())
        self.subcluster_names = list(self.subcluster_name_to_id.keys())

    def _ensure_graph_from_json(self) -> None:
        """
        Si no hay GDF cargado, usa BCclusters.json para:
          - poblar gdf_nodes_top/sub con (id,label_real,size)
          - poblar gdf_edges_top/sub con links (source,target,weight)
        Ignora aristas cruzadas TOP↔SUB. Para SUB exige mismo id_top.
        """
        if not self.cluster_dict:
            return

        # --- Nodos desde JSON si no hay GDF ---
        if not self.gdf_nodes_top and not self.gdf_nodes_sub:
            for cid, n in self.cluster_dict.items():
                if cid in self.removed_clusters:
                    continue
                cid = str(cid)
                label = n.get("label_real") or n.get("label") or cid
                size = int(n.get("size", 1))
                if int(n.get("level",0))==0:
                    self.gdf_nodes_top.append({"id": cid, "label": label, "size": size})
                else:
                    self.gdf_nodes_sub.append({"id": cid, "label": label, "size": size})
        # aristas
        if (not self.gdf_edges_top and not self.gdf_edges_sub) and self.bc_clusters.get("links"):
            for e in self.bc_clusters["links"]:
                s, t = str(e.get("source")), str(e.get("target"))
                if not s or not t or s in self.removed_clusters or t in self.removed_clusters:
                    continue
                try: w = float(e.get("weight", e.get("value", 1.0)))
                except: w = 1.0
                ns, nt = self.cluster_dict.get(s, {}), self.cluster_dict.get(t, {})
                ls, lt = int(ns.get("level",0)), int(nt.get("level",0))
                if ls==0 and lt==0:
                    self.gdf_edges_top.append({"source": s, "target": t, "weight": w})
                elif ls==1 and lt==1:
                    sid_top = str(ns.get("id_top") if ns.get("id_top") is not None else (int(s)//1000 if s.isdigit() else ""))
                    tid_top = str(nt.get("id_top") if nt.get("id_top") is not None else (int(t)//1000 if t.isdigit() else ""))
                    if sid_top == tid_top and sid_top not in self.removed_clusters:
                        self.gdf_edges_sub.append({"source": s, "target": t, "weight": w})

    def _read_text_with_fallback(self, path: str, encodings: Optional[List[str]] = None, *, errors: str = "strict") -> str:
        """
        Lee texto probando múltiples codificaciones en orden.
        Último recurso: decodifica como latin-1 con 'replace' y avisa.
        """
        encs = encodings or ["utf-8", "utf-8-sig", "latin-1", "cp1252"]
        last_err = None
        for enc in encs:
            try:
                with open(path, "r", encoding=enc, errors=errors) as f:
                    return f.read()
            except UnicodeDecodeError as e:
                last_err = e
                continue
        # último recurso: evitar crasheo
        with open(path, "rb") as f:
            raw = f.read()
        text = raw.decode("latin-1", errors="replace")
        if getattr(self, "verbose_notify", False):
            self._notify(
                f"Advertencia: decodifiqué <code>{path}</code> con fallback latin-1 (caracteres sustituidos).",
                "warn"
            )
        return text


    def _parse_labels(self, tex_paths: Union[str, os.PathLike, Sequence[Union[str, os.PathLike]]]) -> Dict[str, str]:
        """Parsea uno o varios TEX de clusters -> dict {id: nombre_real}."""
        if not tex_paths:
            return {}

        # Normalizar a lista
        if isinstance(tex_paths, (str, os.PathLike)):
            tex_paths = [tex_paths]

        labels: Dict[str, str] = {}
        for p in tex_paths:
            if not p:
                continue
            p = str(p)
            if not os.path.exists(p):
                if getattr(self, "verbose_notify", False):
                    self._notify(f"No se encontró TEX: <b>{p}</b>", "warn")
                continue

            # Ej: Cluster 1004 (``PHILOSOPHY'')
            tex = self._read_text_with_fallback(p)  # ⇐ fallback

            labels.update({m[0]: m[1] for m in re.findall(r"Cluster\s+(\d+)\s+\(``(.+?)''\)", tex)})

        return labels

    def _load_labels(self) -> None:
        """Carga labels desde TEX; si faltan, completa desde BCclusters.json."""
        # 1) Intento TEX
        self.label_map_top = self._parse_labels(self.tex_top_clusters) if self.tex_top_clusters else {}
        self.label_map_sub = self._parse_labels(self.tex_sub_clusters) if self.tex_sub_clusters else {}

        # 2) Fallback/merge con JSON si hace falta
        if self.cluster_dict:
            for cid, node in self.cluster_dict.items():
                cid = str(cid)
                lvl = int(node.get("level", 0))
                label = node.get("label_real") or node.get("label") or cid
                if lvl == 0 and cid not in self.label_map_top:
                    self.label_map_top[cid] = str(label)
                elif lvl == 1 and cid not in self.label_map_sub:
                    self.label_map_sub[cid] = str(label)

        self._refresh_label_indexes()

    def _load_bcclusters_json(self) -> None:

      """Carga BCclusters.json y completa label_real (sin borrar nodos salvo que no haya ningún label posible)."""
      self.bc_clusters, self.cluster_dict = {}, {}

      if not self.json_bcclusters or not os.path.exists(self.json_bcclusters):
          if getattr(self, "verbose_notify", False):
              self._notify("No se encontró <b>BCclusters.json</b>. Algunas funciones pueden no estar disponibles.", "warn")
          return

      with open(self.json_bcclusters, encoding="utf-8") as f:
          self.bc_clusters = json.load(f)

      nodes = self.bc_clusters.get("nodes", [])
      self.cluster_dict = {str(n.get("name") or n.get("id")): n for n in nodes}

      for cid, node in self.cluster_dict.items():
          lvl = int(node.get("level", 0))

          # Si el TEX ya definió label para este ID, lo usamos
          label_from_tex = None
          if   (lvl == 0 and cid in self.label_map_top): label_from_tex = self.label_map_top[cid]
          elif (lvl == 1 and cid in self.label_map_sub): label_from_tex = self.label_map_sub[cid]

          if label_from_tex:
              raw = label_from_tex
          else:
              raw_json = node.get("label")
              if not self._is_invalid_label(raw_json):
                  raw = str(raw_json)
              # else:
              #     # fallback desde stuff (K/TK) — si no hay nada, queda vacío
              #     raw = self._infer_label_from_stuff_minimal(node)

          label_norm = self._normalize_label_capital(raw) if raw else ""
          if not label_norm:
              # NO lo marcamos como eliminado todavía; solo vaciamos label_real.
              node["label_real"] = ""
          else:
              node["label_real"] = label_norm

      # Completar mapas desde label_real si el TEX no lo había definido
      for cid, node in self.cluster_dict.items():
          name = (node.get("label_real") or "").strip()
          if not name:
              # último recurso: ID textual (no se elimina el nodo)
              name = str(cid)
          if int(node.get("level", 0)) == 0:
              self.label_map_top.setdefault(cid, name)
          else:
              self.label_map_sub.setdefault(cid, name)

      self._refresh_label_indexes()
    def _load_cooc_json(self) -> bool:
        """
        Carga co-ocurrencia en self.cooc_data = {'nodes':[], 'links':[]}
        - Ruta exacta o variantes coocnetworks*.json(.gz)
        - Busca en el mismo directorio y, si no hay, recursivo bajo self.path_base
        - Usa _load_json_lenient si existe; si no, json.load (con gzip si aplica)
        - Devuelve True si cargó contenido usable
        """
        import os, glob, json
        try:
            import gzip
        except Exception:
            gzip = None

        self.cooc_data = {}
        loaded_ok = False

        # 1) Resolver ruta base; aceptar variantes con sufijo (coocnetworks*.json/.gz)
        if not getattr(self, "json_cooc", None):
            if getattr(self, "verbose_notify", False):
                self._notify("Sin <b>json_cooc</b> configurado; se omite co-ocurrencia.", "warn")
            return False

        cooc_path = self.json_cooc
        if not os.path.isabs(cooc_path):
            cooc_path = os.path.join(getattr(self, "path_base", "."), cooc_path)

        base_dir = os.path.dirname(cooc_path) or "."

        # candidatos: exacto + variantes en el mismo dir
        candidates = []
        if os.path.exists(cooc_path):
            candidates.append(cooc_path)
        candidates += sorted(glob.glob(os.path.join(base_dir, "coocnetworks*.json")))
        candidates += sorted(glob.glob(os.path.join(base_dir, "coocnetworks*.json.gz")))

        # si no hubo suerte, búsqueda recursiva desde path_base
        if not candidates:
            root = getattr(self, "path_base", ".")
            candidates += sorted(glob.glob(os.path.join(root, "**", "coocnetworks*.json"), recursive=True))
            candidates += sorted(glob.glob(os.path.join(root, "**", "coocnetworks*.json.gz"), recursive=True))

        if not candidates:
            if getattr(self, "verbose_notify", False):
                self._notify(
                    f"No se encontró <code>{self.json_cooc}</code> ni variantes "
                    f"<code>coocnetworks*.json(.gz)</code>.", "warn"
                )
            return False

        chosen = candidates[0]

        # 2) Lectura tolerante si existe, si no lectura nativa (con gzip si corresponde)
        try:
            if hasattr(self, "_load_json_lenient") and callable(getattr(self, "_load_json_lenient")):
                data = self._load_json_lenient(chosen)
            else:
                if chosen.endswith(".gz") and gzip is not None:
                    with gzip.open(chosen, "rt", encoding="utf-8-sig") as f:
                        data = json.load(f)
                else:
                    with open(chosen, "r", encoding="utf-8-sig") as f:
                        data = json.load(f)
        except Exception as e:
            if getattr(self, "verbose_notify", False):
                self._notify(f"No se pudo leer JSON '{chosen}': {e}", "warn")
            return False

        if not data:
            return False

        # 3) Normalizar esquema a {nodes, links}
        nodes = data.get("nodes") or data.get("N") or data.get("items") or []
        links = data.get("links") or data.get("E") or data.get("edges") or []

        norm_nodes, norm_links = [], []
        for n in nodes:
            if not isinstance(n, dict):
                continue
            nid = str(n.get("name") or n.get("id") or n.get("key") or "").strip()
            if not nid:
                continue
            norm_nodes.append({
                "name": nid,
                "item": n.get("item", n.get("label", nid)),
                "type": n.get("type", n.get("kind", "")),
                "size": int(n.get("size", n.get("count", 1)) or 1),
            })

        for e in links:
            if not isinstance(e, dict):
                continue
            s = str(e.get("source") or e.get("from") or "").strip()
            t = str(e.get("target") or e.get("to") or "").strip()
            if not s or not t:
                continue
            try:
                w = float(e.get("weight", e.get("value", 1.0)))
            except Exception:
                w = 1.0
            norm_links.append({"source": s, "target": t, "weight": w})

        if not norm_nodes or not norm_links:
            if getattr(self, "verbose_notify", False):
                self._notify(
                    f"Co-ocurrencia en <code>{chosen}</code> sin contenido usable "
                    f"(nodes={len(norm_nodes)}, links={len(norm_links)}).", "warn"
                )
            return False

        self.cooc_data = {"nodes": norm_nodes, "links": norm_links}
        if getattr(self, "verbose_notify", False):
            self._notify(f"Cargada co-ocurrencia desde <code>{chosen}</code> "
                        f"(nodes={len(norm_nodes)}, links={len(norm_links)}).", "ok")
        return True


    def _load_gdf_clusters(self) -> None:
      if not self.gdf_clusters or not os.path.exists(self.gdf_clusters):
          #if getattr(self, "verbose_notify", False):
             # self._notify("No se encontró <b>GDF</b>. Se usarán vistas simplificadas para los grafos.", "warn")
          return

      lines = Path(self.gdf_clusters).read_text(encoding="utf-8").splitlines()


      text = self._read_text_with_fallback(self.gdf_clusters)
      lines = text.splitlines()
      try:
          node_header_idx = next(i for i, l in enumerate(lines) if l.startswith("nodedef>"))
          edge_header_idx = next(i for i, l in enumerate(lines) if l.startswith("edgedef>"))
      except StopIteration:
          self._notify("Formato GDF inválido: faltan encabezados 'nodedef>' o 'edgedef>'.", "error")
          return

      node_header = lines[node_header_idx][len("nodedef>"):]
      node_cols = [c.strip().lower() for c in node_header.split(",")]

      def _col_idx(cands):
          for i, name in enumerate(node_cols):
              for c in cands:
                  if name.startswith(c):
                      return i
          return None

      idx_id    = _col_idx(["name", "id", "node"]) or 0
      idx_level = _col_idx(["level", "type", "group"])   # puede no existir o venir raro
      idx_size  = _col_idx(["size", "weight", "value"])

      # Limpiar estructuras previas (evita duplicados si re-ejecutás)
      self.gdf_nodes_top.clear(); self.gdf_nodes_sub.clear()
      self.gdf_edges_top.clear(); self.gdf_edges_sub.clear()

      tops_seen, subs_seen = set(), set()

      # ---- Parse nodos con prioridad: label_map -> JSON -> GDF -> heurística
      reader = csv.reader(lines[node_header_idx + 1:edge_header_idx], delimiter=",", quotechar='"')
      for r in reader:
          if not r:
              continue
          node_id = r[idx_id].strip().strip('"')
          if not node_id:
              continue

          # --- nivel
          if node_id in self.label_map_top:
              level_tag = "top"
          elif node_id in self.label_map_sub:
              level_tag = "sub"
          else:
              njson = self.cluster_dict.get(node_id)
              if njson is not None:
                  try:
                      level_tag = "sub" if int(njson.get("level", 0)) == 1 else "top"
                  except Exception:
                      level_tag = None
              else:
                  level_tag = None

              if not level_tag:
                  raw_level = (r[idx_level].strip().lower()
                              if idx_level is not None and len(r) > idx_level else "")
                  if raw_level in ("top", "sub"):
                      level_tag = raw_level
                  elif raw_level in ("0", "1"):
                      level_tag = "sub" if raw_level == "1" else "top"
                  else:
                      # heurística por ID
                      level_tag = "sub" if (node_id.isdigit() and len(node_id) >= 4) else "top"

          # --- tamaño
          size = 1
          if idx_size is not None and len(r) > idx_size:
              try:
                  size = int(float(r[idx_size]))
              except Exception:
                  size = 1
          if size == 1 and node_id in self.cluster_dict:
              try:
                  size = int(self.cluster_dict[node_id].get("size", 1))
              except Exception:
                  pass

          # --- label preferente
          if level_tag == "top":
              label = self.label_map_top.get(node_id)
          else:
              label = self.label_map_sub.get(node_id)
          if not label and node_id in self.cluster_dict:
              n = self.cluster_dict[node_id]
              label = n.get("label_real") or n.get("label")
          if not label:
              label = node_id

          # --- sin duplicar
          if level_tag == "top":
              if node_id not in tops_seen:
                  self.gdf_nodes_top.append({"id": node_id, "label": label, "size": size})
                  tops_seen.add(node_id)
          else:
              if node_id not in subs_seen:
                  self.gdf_nodes_sub.append({"id": node_id, "label": label, "size": size})
                  subs_seen.add(node_id)

      # ---- todos los TOP del label_map estén como nodos TOP
      missing_top = set(self.label_map_top.keys()) - tops_seen
      for cid in missing_top:
          n = self.cluster_dict.get(cid, {})
          label = self.label_map_top.get(cid) or n.get("label_real") or n.get("label") or cid
          try:
              size = int(n.get("size", 1))
          except Exception:
              size = 1
          self.gdf_nodes_top.append({"id": cid, "label": label, "size": size})
          tops_seen.add(cid)

      # ---- Edges
      ids_top = tops_seen
      ids_sub = subs_seen
      for line in lines[edge_header_idx + 1:]:
          if not line.strip():
              continue
          parts = [p.strip().strip('"') for p in line.split(",")]
          if len(parts) < 2:
              continue
          s, t = parts[0], parts[1]
          try:
              w = float(parts[2]) if len(parts) > 2 else 1.0
          except Exception:
              w = 1.0
          if s in ids_top and t in ids_top:
              self.gdf_edges_top.append({"source": s, "target": t, "weight": w})
          elif s in ids_sub and t in ids_sub:
              self.gdf_edges_sub.append({"source": s, "target": t, "weight": w})



    # ---------- Helpers genéricos ----------

    def _html_safe(self, s: str) -> str:
        """Escape simple + saltos de línea a <br> para mostrar en HTML."""
        if not s:
            return ""
        s = s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        return s.replace("\n", "<br>")

    def _shorten(self, text: str, max_chars: int = 300) -> str:
        """Devuelve un snippet breve (para tooltip)."""
        if not text:
            return ""
        t = text.strip()
        return (t[:max_chars] + "…") if len(t) > max_chars else t

    def add_cluster_summary(self, cluster_id: str, text: str) -> None:
        """Carga/actualiza el resumen para un cluster (TOP o SUB) por id."""
        cid = str(cluster_id)
        self.cluster_summaries[cid] = self._html_safe(text or "")

    def load_cluster_summaries(self, base_dir: str, filename: str = "cluster_overview.txt", max_chars_per_file: int = 20000) -> int:

        import os, re
        if not base_dir or not os.path.isdir(base_dir):
            self._notify(f"Directorio no válido: <code>{base_dir}</code>", "error")
            return 0

        count = 0
        for entry in os.listdir(base_dir):
            top_path = os.path.join(base_dir, entry)
            if not os.path.isdir(top_path) or not entry.startswith("top_"):
                continue

            # id TOP
            m_top = re.search(r"top_(\d+)", entry)
            if m_top:
                tid = m_top.group(1)
                fpath = os.path.join(top_path, filename)
                if os.path.isfile(fpath):
                    try:
                        txt = open(fpath, encoding="utf-8").read()[:max_chars_per_file]
                        print("LEYENDO: ",fpath)

                        self.cluster_summaries[str(tid)] = self._html_safe(txt)
                        count += 1
                    except Exception:
                        pass

            # subclusters dentro del TOP
            for sub in os.listdir(top_path):
                sub_dir = os.path.join(top_path, sub)
                if os.path.isdir(sub_dir) and sub.startswith("subcluster_"):
                    m_sub = re.search(r"subcluster_(\d+)", sub)
                    if m_sub:
                        sid = m_sub.group(1)
                        f2 = os.path.join(sub_dir, filename)
                        if os.path.isfile(f2):
                            try:
                                txt2 = open(f2, encoding="utf-8").read()[:max_chars_per_file]
                                self.cluster_summaries[str(sid)] = self._html_safe(txt2)
                                print("LEYENDO: ",f2)

                                count += 1
                            except Exception:
                                pass

        self._notify(f"Resúmenes cargados: <b>{count}</b>", "success")
        return count

    def _is_invalid_label(self, s: Optional[str]) -> bool:
        if s is None:
            return True
        s = str(s).strip()
        if not s:
            return True
        if s in {"'", '"', "''", "“", "”", "’", "`"}:
            return True
        if re.fullmatch(r"[\W_]+", s):
            return True
        if re.match(r"(?i)^foolabel[0-9_]*$", s):
            return True
        return False

    def _normalize_label_capital(self, s: str) -> str:
        """
        Title/Capital case, preservando acrónimos:
        - en ACR_WHITELIST (p.ej. STEM)
        - de 2–3 letras (p.ej. AI, NLP, GPU, USA), opcional plural 's' o dígitos
        """
        #if self._is_invalid_label(s):
         #   return ""
        s = re.sub(r"\s+", " ", str(s).strip())

        ACR_WHITELIST = {"STEM", "ICT", "ICTS", "IoT"}
        ACR_2_3 = re.compile(r"^[A-Z]{2,3}(?:s|\d+)?$")  # AI, NLP, GPU, USA, GPUs, AI2

        def fix_token(tok: str) -> str:
            parts = tok.split("-")
            fixed = []
            for p in parts:
                if p.upper() in ACR_WHITELIST or ACR_2_3.fullmatch(p):
                    fixed.append(p.upper())
                else:
                    fixed.append(p.capitalize())
            return "-".join(fixed)

        out = s.upper()
        # out = " ".join(fix_token(t) for t in s.split(" "))
        #return "" if self._is_invalid_label(out) else out
        return out


    def _pick_best(self, paths: list, preferred_basename: Optional[str] = None) -> Optional[str]:
        if not paths:
            return None
        if preferred_basename:
            exact = [p for p in paths if os.path.basename(p).lower() == preferred_basename.lower()]
            if exact:
                return exact[0]
        # preferimos el nombre más corto (menos sufijos), luego alfabético
        return sorted(paths, key=lambda p: (len(os.path.basename(p)), os.path.basename(p)))[0]

    def _resolve_path(self,
                    given: Optional[str] = None,
                    *,
                    default_dir: str,
                    patterns: list[str],
                    preferred_basename: Optional[str] = None) -> Optional[str]:
        base = self.path_base
        # 1) Si me dieron una ruta y existe, la uso
        if given:
            p = given if os.path.isabs(given) else os.path.join(base, given)
            if os.path.exists(p):
                return p

        # 2) Buscar por patrones
        search_dir = os.path.join(base, default_dir)
        cands: list[str] = []
        for pat in patterns:
            cands.extend(glob.glob(os.path.join(search_dir, pat)))

        best = self._pick_best(cands, preferred_basename=preferred_basename)
        if best and getattr(self, "verbose_notify", False):
            self._notify(f"Usando <code>{os.path.relpath(best, base)}</code> (auto-detect).", "info")
        return best

    def _load_json_lenient(self, path: str) -> dict:
      """
      Carga JSON en dos fases con tolerancia:
        1) intenta varias codificaciones (utf-8-sig, utf-8, cp1252, latin-1)
        2) si json.loads falla, sanea el texto y reintenta.
      """
      raw = None
      for enc in ("utf-8-sig", "utf-8", "cp1252", "latin-1"):
          try:
              with open(path, "r", encoding=enc) as f:
                  raw = f.read()
              break
          except UnicodeDecodeError:
              continue

      if raw is None:
          if getattr(self, "verbose_notify", False):
              self._notify(f"No se pudo decodificar <code>{path}</code> como UTF-8/CP1252/Latin-1.", "error")
          return {}

      try:
          return json.loads(raw)
      except json.JSONDecodeError:
          pass  # seguimos al saneo

      try:
          fixed = self._sanitize_json_text(raw)
          return json.loads(fixed)
      except json.JSONDecodeError as e2:
          if getattr(self, "verbose_notify", False):
              self._notify(
                  f"JSON inválido en <code>{path}</code> (línea {e2.lineno}, col {e2.colno}). "
                  f"No fue posible sanear automáticamente."
                  f"{self._preview_error(raw, getattr(e2, 'pos', None))}",
                  "error"
              )
          return {}

    def _repair_item_strings(self, text: str) -> str:
      """
      Repara valores de "item": corrige comillas dobles internas no escapadas
      y saltos de línea dentro del string. Cierra la cadena sólo si lo que sigue
      es ',' o '}' (heurística segura para JSON).
      """
      t = text
      out = []
      i = 0
      n = len(t)
      while i < n:
          idx = t.find('"item"', i)
          if idx == -1:
              out.append(t[i:])
              break
          out.append(t[i:idx])
          i = idx
          # copia literal "item"
          out.append('"item"')
          i += len('"item"')
          # espacios y ':'
          while i < n and t[i].isspace():
              out.append(t[i]); i += 1
          if i < n and t[i] == ':':
              out.append(':'); i += 1
          while i < n and t[i].isspace():
              out.append(t[i]); i += 1

          # esperamos comilla de apertura
          if i < n and t[i] == '"':
              out.append('"'); i += 1
              buf = []
              while i < n:
                  ch = t[i]
                  # normalizar saltos de línea dentro del string
                  if ch in ('\n', '\r'):
                      buf.append(' ')
                      i += 1
                      continue
                  # comilla potencial: ¿cierre o interna?
                  if ch == '"':
                      j = i + 1
                      while j < n and t[j].isspace():
                          j += 1
                      if j < n and (t[j] == ',' or t[j] == '}'):
                          # es el cierre del valor
                          out.append(''.join(buf))
                          out.append('"')
                          i += 1
                          break
                      else:
                          # comilla interna no escapada -> convertir a '
                          buf.append("'")
                          i += 1
                          continue
                  # backslash + siguiente char: conservar tal cual
                  if ch == '\\':
                      if i + 1 < n:
                          buf.append('\\'); buf.append(t[i+1]); i += 2
                      else:
                          i += 1
                      continue
                  buf.append(ch)
                  i += 1
              else:
                  # EOF dentro del string: cerramos para no romper
                  out.append(''.join(buf))
                  out.append('"')
          # si no hay comilla, seguimos (no debería pasar)
      return ''.join(out)


    def _sanitize_json_text(self, text: str) -> str:

        t = text.replace("\r\n", "\n").replace("\ufeff", "")
        # Comentarios tipo JS
        t = re.sub(r"//[^\n]*", "", t)
        t = re.sub(r"/\*.*?\*/", "", t, flags=re.S)

        # Comas colgantes:  ,  ]   o   ,  }
        t = re.sub(r",(\s*[}\]])", r"\1", t)

        # Backslashes no válidos: \X donde X no es comilla, barra, b f n r t u
        t = re.sub(r'(?<!\\)\\(?!["\\/bfnrtu])', r'\\\\', t)

        # Comillas dobles internas no escapadas entre caracteres alfanuméricos (caso genérico tipo D"Ivoire)
        t = re.sub(r'(?<=\w)"(?=\w)', "'", t)

        # Reparación robusta de "item":"...": convierte " internas y \n/\r dentro del string
        t = self._repair_item_strings(t)

        return t


    def _preview_error(self, text: str, pos: Optional[int] = None, window: int = 120) -> str:
        """Snippet HTML alrededor de la posición del error para diagnóstico."""
        try:
            if pos is None:
                return ""
            start = max(0, pos - window)
            end = min(len(text), pos + window)
            snip = (text[start:end]
                    .replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;"))
            return f"<pre style='white-space:pre-wrap;border:1px solid #eee;padding:6px;margin-top:6px'>{snip}</pre>"
        except Exception:
            return ""

    def _index_subclusters_by_top(self) -> None:
        self.subclusters_by_top = {}
        for cid, node in self.cluster_dict.items():
            if int(node.get("level",0)) != 1 or cid in self.removed_clusters:
                continue
            id_top = node.get("id_top")
            if id_top is None:
                try: id_top = str(int(cid)//1000)
                except: continue
            tid = str(id_top)
            if tid in self.removed_clusters:
                continue
            self.subclusters_by_top.setdefault(tid, []).append(str(cid))



    def plot_map(
        self,
        *,
        colorscale: str = "Turbo",
        height: int = 650,
        globe: bool = False,
        center_lon: float = -30.0,
        center_lat: float = 0.0,
        title: str = "<b>Countries — Global Publications Distribution</b>",
    ):

        assert self.countries_global_df is not None and not self.countries_global_df.empty

        df = self.countries_global_df.copy()
        df = df.dropna(subset=["country"])
        df["country"]  = df["country"].astype(str).str.strip()
        df["articles"] = pd.to_numeric(df["articles"], errors="coerce").fillna(0).astype(int)
        df["frequency"] = pd.to_numeric(df["frequency"], errors="coerce").fillna(0.0)


        df = (df.groupby("country", as_index=False)
                .agg(articles=("articles", "sum"),
                    frequency=("frequency", "max")))

        # % en 0–100 para colorear y para hover
        freq = df["frequency"].astype(float)
        if float(freq.max()) <= 1.0 + 1e-9:
            freq = freq * 100.0
        df["_freq100"] = freq.clip(0, 100)

        # z = frecuencia en 0–100; rango fijo para que 99.99 = extremo de la escala
        z = df["_freq100"].astype(float).to_numpy()
        zmin, zmax = 0.0, 100.0

        # Hover minimal
        hovertext = (
            "<b>" + df["country"] + "</b><br>"
            + "Artículos: " + df["articles"].map("{:,}".format) + "<br>"
            + "Frecuencia: " + df["_freq100"].map(lambda x: f"{x:.2f}%")
        )

        fig = go.Figure(
            data=go.Choropleth(
                locations=df["country"],          # SIN ISO3
                locationmode="country names",
                z=z,
                zauto=False, zmin=zmin, zmax=zmax,
                colorscale=colorscale,
                autocolorscale=False,
                text=hovertext,
                hoverinfo="text",
                marker_line_color="white",
                marker_line_width=0.6,
                showscale=True,
                colorbar=dict(title="Frecuencia (%)"),
            )
        )

        proj = "orthographic" if globe else "natural earth"
        fig.update_geos(
            showframe=False,
            showcoastlines=True,
            coastlinecolor="rgba(90,90,90,0.4)",
            projection_type=proj,
            projection_rotation=dict(lon=center_lon, lat=center_lat) if globe else None,
            showocean=True,
            oceancolor="rgba(173, 216, 230, 0.35)",
            landcolor="rgba(255,255,255,0.0)",
            bgcolor="rgba(0,0,0,0)",
            countrycolor="rgba(80,80,80,0.4)",
        )
        fig.update_layout(
            title=dict(text=title, x=0.5, xanchor="center"),
            height=height,
            margin=dict(l=0, r=0, t=60, b=0),
            hoverlabel=dict(bgcolor="white", font_size=14),
        )
        return fig


    def plot_countries_map_global(
        self,
        *,
        engine: str = "plotly",
        height: int = 650,
        colorscale: str = "Viridis",
        show_values_as_percent: bool = True,
    ):
        """
        Mapa mundial global (usando el DF precalculado en __init__).
        Más estético, con efecto hover, bordes suaves y fondo azulado.
        """
        import pandas as pd
        import plotly.graph_objects as go
        import plotly.express as px

        if self.countries_global_df is None or self.countries_global_df.empty:
            self._notify("No hay datos globales de países. Ejecutá tyk.refresh_aggregates().", "warn")
            return

        df = self.countries_global_df.copy()
        df = df.dropna(subset=["country"])
        df = df.rename(columns={"frequency": "value"})
        df["value"] = df["value"].fillna(0)

        # Resolver ISO3
        def _country_to_iso3(name: str):
            import pycountry
            aliases = {
                "United States": "USA", "United States of America": "USA",
                "UK": "GBR", "England": "GBR", "Russia": "RUS", "Iran": "IRN",
                "South Korea": "KOR", "North Korea": "PRK", "Czech Republic": "CZE",
                "Taiwan": "TWN", "Viet Nam": "VNM", "Hong Kong": "HKG",
                "Democratic Republic of the Congo": "COD", "Ivory Coast": "CIV"
            }
            name = str(name).strip()
            if name in aliases:
                return aliases[name]
            try:
                return pycountry.countries.search_fuzzy(name)[0].alpha_3
            except Exception:
                return None

        df["iso3"] = df["country"].apply(_country_to_iso3)
        df = df.dropna(subset=["iso3"])

        if df.empty:
            self._notify("No se pudieron mapear países a códigos ISO3.", "error")
            return

        # Formateo del valor en hover

        hover_text = []
        for _, r in df.iterrows():
            val = r["value"]
            arts = int(r.get("articles", 0))
            val_str = f"{int(round(float(arts)))}".replace(".", ",")

            hover_text.append(
                f"<b>{r['country']}</b><br>"
                f"{('Frecuencia: ' + f'{val:.2f}%') if show_values_as_percent else 'Valor: ' + f'{val:,}'}<br>"
                f"Artículos: {val_str}"
            )
        df["hover"] = hover_text

        # ---- Plotly choropleth con estilo mejorado ----
        fig = go.Figure(
            data=go.Choropleth(
                locations=df["iso3"],
                z=df["value"],
                text=df["hover"],
                hoverinfo="text",
                colorscale=colorscale,
                colorbar_title="Frecuencia (%)" if show_values_as_percent else "Cantidad",
                marker_line_color="white",
                marker_line_width=0.6,
                reversescale=False,
                showscale=True,
            )
        )

        fig.update_layout(
            title=dict(
                text="<b>Countries — Global Publications Distribution</b>",
                x=0.5,
                xanchor="center",
                yanchor="top",
                font=dict(size=20, color="#222"),
            ),
            geo=dict(
                showframe=False,
                showcoastlines=True,
                coastlinecolor="rgba(90,90,90,0.4)",
                projection_type="natural earth",
                showocean=True,
                oceancolor="rgba(173, 216, 230, 0.35)",
                landcolor="rgba(255,255,255,0.0)",
                bgcolor="rgba(0,0,0,0)",
                countrycolor="rgba(80,80,80,0.4)",
            ),
            height=height,
            margin=dict(l=0, r=0, t=60, b=0),
            hoverlabel=dict(
                bgcolor="white",
                font_size=14,
                font_family="Inter, sans-serif",
                font_color="#111",
            ),
        )

        # ---- Mostrar el mapa ----
        try:
            import plotly.io as pio
            pio.show(fig)
        except Exception:
            from IPython.display import HTML, display
            import plotly.io as pio
            display(HTML(pio.to_html(fig, include_plotlyjs="cdn", full_html=False)))

            #SIMPLE:
    # def plot_countries_map_global(self, *, engine: str = "plotly", height: int = 620, colorscale: str = "YlOrRd"):
    #     """
    #     Mapa mundial global (usando el DF precalculado en __init__).
    #     """
    #     if self.countries_global_df is None or self.countries_global_df.empty:
    #         self._notify("No hay datos globales de países. Intentá run: tyk.refresh_aggregates().", "warn")
    #         return
    #     df = self.countries_global_df.rename(columns={"frequency": "value"})
    #     self._plot_countries_from_df(df, title="Countries — Global", engine=engine, colorscale=colorscale, height=height)

    # ------------------------ API PÚBLICA ------------------------

    def list_clusters(self, top: bool = True, show: bool = True):
        """Devuelve [(id, nombre)] y, si show=True, renderiza una tabla amigable."""
        keyer = lambda x: (0, int(x)) if str(x).isdigit() else (1, str(x))
        removed = getattr(self, "removed_clusters", set())

        if top:
            ids = [cid for cid in self.label_map_top if cid not in removed]
            pairs = [(cid, self._normalize_label_capital(self.label_map_top[cid])) for cid in sorted(ids, key=keyer)]
            if show:
                return self._render_clusters_table(pairs, level="TOP")

            return pairs

        ids = [cid for cid in self.label_map_sub if cid not in removed]
        pairs = [(cid, self._normalize_label_capital(self.label_map_sub[cid])) for cid in sorted(ids, key=keyer)]
        if show:
            return self._render_clusters_table(pairs, level="SUB")

        return pairs


    def list_subclusters(self, top_id: str, show: bool = True):
        """Devuelve [(id_sub, nombre_sub)] del TOP dado y, si show=True, renderiza tabla."""
        tid = str(top_id)
        keyer = lambda x: (0, int(x)) if str(x).isdigit() else (1, str(x))
        removed = getattr(self, "removed_clusters", set())
        subs = [sid for sid in self.subclusters_by_top.get(tid, []) if sid not in removed]
        subs = sorted(subs, key=keyer)

        pairs = []
        for sid in subs:
            name = self._normalize_label_capital(
                self.label_map_sub.get(sid) or self.cluster_dict.get(sid, {}).get("label_real", sid)
            )
            pairs.append((sid, name))
        if show:
            return self._render_clusters_table(pairs, level="SUB", top_id=tid)
        return pairs


    # ---------- ÚNICO renderer para TOP y SUB (corrige estilo claro) ----------

    def _render_clusters_table(self, pairs: list, level: str, top_id: str = None):
        """
        Render de tabla para TOP y SUB.
        level: "TOP" | "SUB"
        top_id: si viene para SUB, no muestra la columna TOP (porque ya está filtrado).
        """
        from IPython.display import HTML, display

        if not pairs:
            if level == "TOP":
                self._notify("No hay clusters TOP disponibles.", "warn")
            else:
                if top_id:
                    self._notify(f"El TOP <b>{self.label_map_top.get(top_id, top_id)}</b> no tiene subclusters.", "warn")
                else:
                    self._notify("No hay subclusters para mostrar.", "warn")
            return

        # Encabezado y columnas según nivel
        show_top_col = (level == "SUB" and not top_id)
        if level == "TOP":
            thead = (
                "<th style='padding:10px;text-align:left'>#</th>"
                "<th style='padding:10px;text-align:left'>ID</th>"
                "<th style='padding:10px;text-align:left'>Nombre</th>"
                "<th style='padding:10px;text-align:right'>Artículos</th>"
                "<th style='padding:10px;text-align:right'>Subclusters</th>"
            )
        else:
            thead = (
                "<th style='padding:10px;text-align:left'>#</th>"
                "<th style='padding:10px;text-align:left'>ID</th>"
                "<th style='padding:10px;text-align:left'>Nombre</th>"
                "<th style='padding:10px;text-align:right'>Artículos</th>"
                + ("<th style='padding:10px;text-align:left'>TOP</th>" if show_top_col else "")
            )

        # Filas
        rows_html = []
        for i, (cid, name) in enumerate(pairs, start=1):
            c = self.cluster_dict.get(cid, {})
            size = int(c.get("size", 0))
            if level == "TOP":
                nsubs = len(self.subclusters_by_top.get(cid, []))
                extra_cells = f"<td style='padding:8px 12px; text-align:right'>{nsubs}</td>"
            else:
                top_name = ""
                if show_top_col:
                    tid = str(c.get("id_top")) if c.get("id_top") is not None else str(int(cid)//1000 if str(cid).isdigit() else "")
                    top_name = self.label_map_top.get(tid, tid)
                extra_cells = (f"<td style='padding:8px 12px'>{top_name}</td>" if show_top_col else "")

            rows_html.append(
                "<tr>"
                f"<td style='padding:8px 12px'>{i}</td>"
                f"<td style='padding:8px 12px'><code>{cid}</code></td>"
                f"<td style='padding:8px 12px'>{name}</td>"
                f"<td style='padding:8px 12px; text-align:right'>{size}</td>"
                f"{extra_cells}"
                "</tr>"
            )
        body = "".join(rows_html)

        title = (
            f"Clusters <b>TOP</b> disponibles (total: {len(pairs)})"
            if level == "TOP"
            else (
                f"Subclusters de <b>{self.label_map_top.get(top_id, top_id)}</b> (ID {top_id}) (total: {len(pairs)})"
                if top_id else f"Subclusters disponibles (total: {len(pairs)})"
            )
        )

        # Estilos: alto contraste (texto #222), fondo blanco, zebra rows
        html = f"""
        <details open style="margin:10px 0">
          <summary style="cursor:pointer; font-family:sans-serif">{title}</summary>
          <div style="margin-top:10px; max-width:1100px;">
            <table style="width:100%; border-collapse:collapse; font-family:sans-serif; background:#ffffff; color:#222;
                          border:1px solid #d7dbe2;">
              <thead style="background:#eef2f7; color:#222; border-bottom:1px solid #d7dbe2;">
                <tr>{thead}</tr>
              </thead>
              <tbody>
                {body}
              </tbody>
            </table>
          </div>
        </details>
        <style>
          details table tbody tr:nth-child(odd)  {{ background:#fafbfe; }}
          details table tbody tr:nth-child(even) {{ background:#ffffff; }}
          details table code {{ color:#374151; background: #f3f4f6; padding:2px 6px; border-radius:4px; }}
        </style>
        """

        hint = (
            "Elegí un <b>TOP</b> por <b>ID</b> o por <b>Nombre</b> donde corresponda."
            if level == "TOP"
            else ("Elegí un <b>SUB</b> por <b>ID</b> o <b>Nombre</b> para visualizar."
                  if top_id else "Indicá primero un <b>TOP</b> para filtrar sus subclusters.")
        )
        self._notify(hint, "info")
        display(HTML(html))

    def get_cluster(self, cluster_id: str) -> Dict[str, Any]:
        c = self.cluster_dict.get(str(cluster_id))
        if not c:
            raise ValueError(f"Cluster {cluster_id} no encontrado en BCclusters.json")
        return c

    # -------- GRAFOS --------
    def _render_vis_network(
        self,
        nodes: list,
        edges: list,
        title: str = "Red interactiva",
        *,
        palette: str = "YlGnBu",     # "YlGnBu" | "rainbow" | cualquier cmap de Matplotlib
        show_colorbar: bool = True,   # muestra una leyenda tipo colorbar (min↔max)
        scaling_min: int = 8,          # tamaño mínimo de nodo (px)
        scaling_max: int = 36,          # tamaño máximo de nodo (px)  ← ¡subido!
        height_px: int = 680 ,           # alto del canvas
        mode: str = "auto",          # <-- NUEVO: "auto" | "inline" | "browser"
        outfile: Optional[str] = None,  # <-- NUEVO: ruta opcional para guardar
        open_in_browser: bool = True,    # <-- NUEVO: abrir automáticamente
        show_summary_panel: bool = False,          # <<< NUEVO
        summaries_map: Optional[Dict[str, str]] = None  # <<< NUEVO (id -> HTML)
    ) -> None:

        # --- rango para la leyenda (usar crudo si existe) ---
        vals = [float(n.get("raw", n.get("value", 1))) for n in nodes] or [1.0]

        vmin, vmax = (min(vals), max(vals))
        try:
            cmap = colormaps.get_cmap(palette)
        except Exception:
            cmap = colormaps.get_cmap("YlGnBu")

        # Gradiente CSS para la barra (coincide con el colormap)
        gradient_css = "linear-gradient(to top, " + ", ".join(
            mcolors.to_hex(cmap(i/255.0)) for i in range(256)
        ) + ")"

        # --- insertar snippet corto en 'title' (tooltip) si hay summaries
        if summaries_map:
            for n in nodes:
                nid = str(n.get("id"))
                if nid in summaries_map and not n.get("title"):
                    snippet = self._shorten(summaries_map[nid], 280)
                    # 'title' es HTML simple y lo muestra vis-network como tooltip
                    n["title"] = f"<b>{n.get('label','')}</b><br><div style='max-width:360px'>{snippet}</div>"

        div_id = f"vis_{uuid.uuid4().hex}"
        panel_id = f"panel_{uuid.uuid4().hex}"

        # --- Opciones de vis-network (JSON válido) ---

        options_json = f"""
            {{
              "physics": {{
                "enabled": true,
                "solver": "barnesHut",
                "barnesHut": {{
                  "gravitationalConstant": -25000,
                  "springLength": 180,
                  "springConstant": 0.03,
                  "damping": 0.85,
                  "avoidOverlap": 0.3
                }},
                "minVelocity": 0.75,
                "stabilization": {{ "iterations": 200 }}
              }},
              "interaction": {{ "hover": true, "dragNodes": true, "dragView": true, "zoomView": true }},
              "edges": {{
                "smooth": false,
                "color": {{ "color": "rgba(120,120,120,0.28)", "highlight": "rgba(100,100,100,0.50)" }}
              }},
              "nodes": {{
                "shape": "dot",
                "scaling": {{ "min": {scaling_min}, "max": {scaling_max} }},
                "font": {{ "face": "Inter, Arial, sans-serif", "size": 14, "color": "#233" }},
                "borderWidth": 1
              }},
              "layout": {{ "improvedLayout": true, "randomSeed": 7 }}
            }}
            """.strip()
        # --- utilidades
        def _slug(s: str) -> str:
            s = re.sub(r"\s+", "_", s.strip())
            s = re.sub(r"[^\w\-.]+", "", s)
            return s[:80] or "graph"

        def _env_is_vscode():
            return "VSCODE_PID" in os.environ  # heurística simple

        # --- Colorbar (opcional), pegado al contenedor del grafo ---
        colorbar_html = ""
        if show_colorbar:
            colorbar_html = f"""
            <div style="position:absolute; top:16px; right:16px; background:white; border:1px solid #e1e5ea;
                        border-radius:6px; padding:8px 12px; font-family:sans-serif; font-size:14px; color:#222; text-align:center;">
              <div style="font-weight:600; margin-bottom:6px;">Tamaño</div>
              <div style="margin-bottom:4px;">{int(vmax)}</div>
              <div style="width:22px; height:160px; background:{gradient_css}; border:1px solid #ccc; margin:0 auto;"></div>
              <div style="margin-top:4px;">{int(vmin)}</div>
            </div>
            """

        # panel superior de resumen (si se activa)
        panel_html = ""
        if show_summary_panel:
            panel_html = f"""
            <div id="{panel_id}" style="margin:6px 0 10px 0; padding:10px 12px; border:1px solid #d8e4ff;
                border-radius:8px; background:#f6f9ff; font-family:sans-serif; color:#123;">
              <b>Tip:</b> hacé clic en un nodo para ver el resumen aquí.
            </div>
            """

        # JS: carga vis-network + click -> muestra resumen
        nodes_json = json.dumps(nodes, ensure_ascii=False)
        edges_json = json.dumps(edges, ensure_ascii=False)
        summaries_json = json.dumps(summaries_map or {}, ensure_ascii=False)

        tooltip_html = f"""
        <div id="{div_id}_tip"
            style="position:absolute; display:none; pointer-events:none;
                    background:white; border:1px solid #ddd; border-radius:6px;
                    padding:8px 10px; box-shadow:0 2px 10px rgba(0,0,0,.12);
                    max-width:320px; z-index:3; color:#111; font-family:sans-serif; font-size:13px;">
        </div>
        """

        html = f"""
        <div style="font-family:sans-serif;margin:6px 0 10px 0;font-weight:600">{title}</div>
        {panel_html}
        <div style="position:relative;">
          <div id="{div_id}" style="width:100%; height:{height_px}px; border:1px solid #e1e5ea; border-radius:8px; background-color:white;"></div>
          {colorbar_html}
          {tooltip_html}
        </div>

        <script type="text/javascript">
        (function(){{
          function ensureVis(callback) {{
            if (window.vis && window.vis.Network) {{ callback(); return; }}
            var s = document.createElement('script');
            s.src = "https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js";
            s.onload = callback;
            document.head.appendChild(s);
            var l = document.createElement('link');
            l.rel = "stylesheet";
            l.href = "https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.css";
            document.head.appendChild(l);
          }}

          ensureVis(function() {{
            var container = document.getElementById("{div_id}");
            var tip       = document.getElementById("{div_id}_tip");

            var data = {{
              nodes: new vis.DataSet({json.dumps(nodes)}),
              edges: new vis.DataSet({json.dumps(edges)})
            }};
            var options   = {options_json};
            var network   = new vis.Network(container, data, options);
            var SUMMARIES = {summaries_json};
            var panel     = document.getElementById("{panel_id}");

            // ---- CLICK: mostrar resumen en el panel ----
            network.on("click", function(params){{
              if (!panel) return;
              if (params.nodes && params.nodes.length) {{
                var nid   = String(params.nodes[0]);
                var node  = data.nodes.get(nid);
                var title = (node && node.label) ? node.label : "Cluster";
                var txt   = SUMMARIES[nid] || "<i>Sin resumen disponible.</i>";
                panel.innerHTML =
                  "<div style='font-family:sans-serif'>" +
                    "<div style='font-weight:600; margin-bottom:6px;'>" + title + "</div>" +
                    "<div style='line-height:1.45;'>" + txt + "</div>" +
                  "</div>";
              }}
            }});  // <-- ¡cerrar el handler de click!

            // ---- TOOLTIP flotante (hover) ----
            function moveTip(evt) {{
              if (!evt) return;
              var rect = container.getBoundingClientRect();
              var x = (evt.clientX - rect.left) + 14;
              var y = (evt.clientY - rect.top)  + 14;
              tip.style.left = x + "px";
              tip.style.top  = y + "px";
            }}

            network.on("hoverNode", function(params){{
              var n = data.nodes.get(params.node);
              if (n && n.title) {{
                tip.innerHTML = n.title;
                tip.style.display = "block";
              }}
            }});

            network.on("blurNode", function() {{
              tip.style.display = "none";
            }});

            network.on("dragging", function(p) {{
              if (tip.style.display === "block" && p.event && p.event.srcEvent) {{
                moveTip(p.event.srcEvent);
              }}
            }});

            network.on("pointerMove", function(p) {{
              if (tip.style.display === "block" && p.event && p.event.srcEvent) {{
                moveTip(p.event.srcEvent);
              }}
            }});

            network.once("stabilizationIterationsDone", function(){{
              network.fit({{ animation: {{ duration: 500, easing: 'easeInOutQuad' }} }});
            }});
          }});
        }})();
        </script>
        """

        def _save_and_open(_html: str):
            base_dir = self.dat_folder or self.path_base or "."
            os.makedirs(base_dir, exist_ok=True)
            name = outfile or f"{_slug(title)}.html"
            outpath = os.path.join(base_dir, name)
            with open(outpath, "w", encoding="utf-8") as f:
                f.write(_html)
            if getattr(self, "verbose_notify", False):
                self._notify(f"Grafo guardado en <code>{outpath}</code>.", "info")
            if open_in_browser:
                try:
                    webbrowser.open("file://" + os.path.abspath(outpath))
                except Exception:
                    pass

        try_inline = (mode == "inline") or (mode == "auto" and not _env_is_vscode())
        if try_inline:
            try:
                display(HTML(html))
                return
            except Exception:
                # si falla inline, caemos a archivo+browser
                _save_and_open(html)
                return

        # modo "browser" o "auto" con VS Code
        _save_and_open(html)


    def plot_clusters_graph_interactive(
        self,
        min_edge_weight: float = 0.0,
        title: str = "Grafo de Clusters (TOP)",
        mode: str = "auto",
    ) -> None:
        # --- Nodos TOP desde GDF (si hay) ---
        nodes_raw = list(self.gdf_nodes_top) if self.gdf_nodes_top else []

        # --- Unión con TOP esperados por JSON (por si el GDF trajo menos) ---
        expected_top_ids = {cid for cid, n in self.cluster_dict.items() if int(n.get("level", 0)) == 0}
        have_ids = {n["id"] for n in nodes_raw}
        missing = expected_top_ids - have_ids

        for cid in missing:
            n = self.cluster_dict.get(cid, {})
            nodes_raw.append({
                "id": cid,
                "label": self._display_label(cid),
                "size": int(n.get("size", 1) or 1),
            })

        # --- Aristas TOP (solo si hay GDF) ---
        edges_raw = [e for e in self.gdf_edges_top if float(e.get("weight", 0)) >= min_edge_weight] if self.gdf_edges_top else []

        # --- Coloreo / tamaño ---
       # --- Coloreo / tamaño ---
        cmap = colormaps.get_cmap('YlGnBu')
        sizes = [int(n.get("size", 1)) for n in nodes_raw] or [1]
        norm = mcolors.Normalize(vmin=min(sizes), vmax=max(sizes))

        nodes = []
        for n in nodes_raw:
            nid = n["id"]
            # nombre bonito (prefiere label del TEX si existe)
            # pretty_label = self._display_label(cid)

            pretty_label = self.label_map_top.get(nid) or n.get("label", nid)
            # artículos reales desde el JSON (fallback al size del nodo)
            articles = int(self.cluster_dict.get(nid, {}).get("size", n.get("size", 0) or 0))
            # valor para color/escala
            val = articles if articles else int(n.get("size", 1))
            col = mcolors.to_hex(cmap(norm(max(val, 1))))

            # tooltip HTML (vis-network usa 'title' para hover)
            title_html = (
                f"<div style='font-size:13px'>"
                f"<b>{pretty_label}</b><br>"
                f"ID: <code>{nid}</code><br>"
                f"Artículos: <b>{articles}</b>"
                f"</div>"
            )

            nodes.append({
                "id": nid,
                "label": pretty_label,
                "title": title_html,       # ← tooltip con ID + artículos
                "value": val,              # usado para tamaño visual
                "color": {
                    "background": col,
                    "border": "#334",
                    "highlight": {"background": col, "border": "#222"}
                }
            })


        edges = []
        for e in edges_raw:
            w = float(e.get("weight", 1.0))
            edges.append({"from": e["source"], "to": e["target"], "value": w, "width": max(1.0, w/2.0)})

        self._render_vis_network(nodes, edges, title=title, mode=mode, show_summary_panel=True,
          summaries_map=self.cluster_summaries)



    def plot_subclusters_graph_interactive(
        self,
        top_val: str,                    # ID o nombre del TOP
        min_edge_weight: float = 0.0,
        title: Optional[str] = None,
        mode: str = "auto",          # <-- NUEVO: "auto" | "inline" | "browser"

    ) -> None:
        """
        Subclusters interactivo para un TOP (ID o nombre), con colores por tamaño (Viridis).
        Usa aristas SUB-SUB si existen; si no, grafo estrella TOP→SUB.
        """
        tid = self._resolve_top_id(top_val)
        if not tid:
            self._notify(f"TOP <b>{top_val}</b> no encontrado (usá ID o nombre exacto).", "error")
            return

        subs = self.subclusters_by_top.get(tid, [])
        if not subs:
            self._notify(f"El TOP <b>{self.label_map_top.get(tid, tid)}</b> (ID {tid}) no tiene subclusters.", "warn")
            return

        # Datos de nodos SUB
        sizes = []
        nodes = []
        for sid in subs:
            n = self.cluster_dict.get(sid, {})
            sizes.append(int(n.get("size", 1)))

        cmap = colormaps.get_cmap('YlGnBu')
        norm = mcolors.Normalize(vmin=min(sizes), vmax=max(sizes))
        for sid in subs:
            n = self.cluster_dict.get(sid, {})
            val = int(n.get("size", 1))
            col = mcolors.to_hex(cmap(norm(val)))

            label = n.get("label_real", sid)
            nodes.append({
                "id": sid, "label": label, "title": f"{label} · tamaño: {val}",
                "value": val,
                "color": {"background": col, "border": "#334",
                          "highlight": {"background": col, "border": "#222"}}
            })

        # Aristas sub-sub si existen; si no, estrella
        edges = []
        if self.gdf_edges_sub and self.gdf_nodes_sub:
            sub_set = set(subs)
            def _top_of(sub_id: str) -> str:
                n = self.cluster_dict.get(sub_id, {})
                return str(n.get("id_top") if n.get("id_top") is not None else int(sub_id)//1000)
            for e in self.gdf_edges_sub:
                s, t = e["source"], e["target"]
                if s in sub_set and t in sub_set and _top_of(s) == tid and _top_of(t) == tid:
                    w = float(e.get("weight", 1.0))
                    if w >= min_edge_weight:
                        edges.append({"from": s, "to": t, "value": w, "width": max(1.0, w/2.0)})
        if not edges:
            center_id = f"TOP-{tid}"
            top_label = self.label_map_top.get(tid, center_id)
            # tamaño del TOP como promedio visual
            avg = max(20, int(sum(n["value"] for n in nodes) / len(nodes)))
            nodes.append({
                "id": center_id, "label": top_label, "title": top_label,
                "value": avg, "color": {"background": "#e9eef8", "border": "#334"}
            })
            for n in nodes:
                if n["id"] != center_id:
                    edges.append({"from": center_id, "to": n["id"], "value": n["value"], "width": max(1.0, n["value"]/2.0)})
            if title is None:
                title = f"Subclusters de {top_label}"

        if title is None:
            title = f"Subclusters de {self.label_map_top.get(tid, '')}"

        self._render_vis_network(nodes, edges, title=title, mode=mode, show_summary_panel=True,
          summaries_map=self.cluster_summaries)

    def plot_cooc_network_interactive(
        self,
        node_type: str = "K",
        min_node_size: int = 5,
        min_edge_weight: float = 0.0,
        title: str = "Red de co-ocurrencia",
        palette: str = "YlGnBu",
        max_nodes: int = 250,           # tope de nodos mostrados (mayores por 'size')
        topk_per_node: int = 5,         # mantiene solo las k aristas más pesadas por nodo
        node_size_range: tuple = (18, 60),  # rango visual (px) para nodos
        height_px: int = 720,
        mode: str = "auto",          #  "auto" | "inline" | "browser"

    ) -> None:
        """
        Red de co-ocurrencia interactiva (vis-network) optimizada:
          - Limita a 'max_nodes' (mantiene los más grandes).
          - Sparsifica edges: top-k más pesadas por nodo + umbral de peso.
          - Nodos más grandes (rango node_size_range).
        Renderiza HTML interactivo embebido con colorbar.
        """
        if not self.cooc_data:
            self._notify("Sin datos de co-ocurrencia cargados. No es posible graficar la red.", "warn")
            return

        # --- Filtrar nodos por tipo ---
        # print(self.cooc_data.get("nodes", []))

        nodes_raw = [n for n in self.cooc_data.get("nodes", []) if n.get("type") == node_type]
        if not nodes_raw:
            self._notify(f"No se encontraron nodos del tipo <b>{node_type}</b>.", "warn")
            return

        # --- Ordenar por size y recortar a max_nodes ---
        nodes_raw.sort(key=lambda n: int(n.get("size", 1)), reverse=True)
        nodes_raw = nodes_raw[:max(1, int(max_nodes))]
        node_ids = {str(n.get("name")) for n in nodes_raw}
        node_by_id = {str(n.get("name")): n for n in nodes_raw}

        # --- Aristas: filtrar por nodos presentes y aplicar top-k por nodo + umbral ---
        edges_dict = defaultdict(list)  # por nodo, lista (peso, vecino)
        for e in self.cooc_data.get("links", []):
            s, t = str(e.get("source")), str(e.get("target"))
            if s in node_ids and t in node_ids:
                w = float(e.get("weight", 1.0))
                if w >= float(min_edge_weight):
                    edges_dict[s].append((w, t))
                    edges_dict[t].append((w, s))

        # mantener solo las k más pesadas por nodo (sin duplicar aristas)
        kept_edges = set()
        for u, lst in edges_dict.items():
            for w, v in heapq.nlargest(int(topk_per_node), lst, key=lambda x: x[0]):
                a, b = (u, v) if u < v else (v, u)
                kept_edges.add((a, b, w))

        # --- Colormap & escalado de tamaño visual ---
        try:
            cmap = colormaps.get_cmap(palette)
        except Exception:
            cmap = colormaps.get_cmap("YlGnBu")

        sizes_raw = [int(node_by_id[nid].get("size", 1)) for nid in node_ids] or [1]
        vmin, vmax = min(sizes_raw), max(sizes_raw)
        norm = mcolors.Normalize(vmin=vmin, vmax=vmax)

        def _lin(v, a0, a1, b0, b1):
            if a1 <= a0: return (b0 + b1) / 2.0
            x = (v - a0) / (a1 - a0)
            return b0 + x * (b1 - b0)

        vmin_px, vmax_px = node_size_range
        nodes = []
        for nid in node_ids:
            n = node_by_id[nid]
            label = str(n.get("item", nid))
            raw_size = int(n.get("size", 1))

            # tamaño visual en píxeles (clamp)
            vis_size = _lin(raw_size, vmin, vmax, vmin_px, vmax_px)
            vis_size = max(vmin_px, min(vmax_px, vis_size))

            color = mcolors.to_hex(cmap(norm(raw_size)))
            nodes.append({
                "id": nid,
                "label": label,
                "title": f"{label} · tamaño: {raw_size}",  # muestra el crudo (ej. 83)
                "value": vis_size,                         # tamaño visual (px)
                "raw": raw_size,                           # <-- NUEVO: valor crudo para la colorbar
                "color": {
                    "background": color,
                    "border": "#334",
                    "highlight": {"background": color, "border": "#222"}
                }
            })

        # --- Edges finales (sutiles) ---
        edges = [{"from": a, "to": b, "value": w, "width": max(1.0, w/2.5)} for a, b, w in kept_edges]

        pretty_type = self.stuff_titles.get(node_type, node_type)
        final_title = f"{title} — {pretty_type} (n={len(nodes)})"

        self._render_vis_network(
            nodes, edges, title=final_title,
            palette=palette, show_colorbar=True,
            scaling_min=int(vmin_px * 0.8), scaling_max=int(vmax_px), height_px=height_px, mode=mode
        )


    # ------------------------ DESCRIPCIÓN CLUSTER ------------------------
    def describe_cluster_params(
         self,
        level: str,                # "TOP" | "SUB"  (en Colab: @param ["TOP","SUB"])
        stuff_type: str,           # (en Colab: @param ["K","TK","S","S2","J","C","I","R","RJ","A","MCAU","MCP","MRP","Y"])
        cluster_top: str = "",     # ID o nombre TOP
        cluster_sub: str = "",     # ID o nombre SUB (dentro del TOP elegido)
        listar_max: int = 20,
    )-> None:
        """
          Modo @param minimalista para notebooks.
          * Si level=TOP y no pasás cluster_top → lista TOPs.
          * Si level=SUB, pide primero cluster_top; si no hay cluster_sub → lista los SUB de ese TOP.
          """
        lvl = (level or "TOP").upper()
        if lvl not in ("TOP", "SUB"):
          self._notify(f"Nivel inválido: <b>{level}</b>. Usá <b>TOP</b> o <b>SUB</b>.", "error")
          return

        pairs = [(cid, self.label_map_top[cid]) for cid in sorted(self.label_map_top, key=int)]
        # self._render_candidates_table("Clusters TOP disponibles", pairs, limit=listar_max)

        if lvl == "TOP":
            # Si no hay TOP elegido, listamos opciones y salimos
            if not cluster_top.strip():
                # pairs = [(cid, self.label_map_top[cid]) for cid in sorted(self.label_map_top, key=int)]
                self._render_candidates_table("Clusters TOP disponibles", pairs, limit=listar_max)
                display(HTML("<div style='margin-top:6px;color:#666'>Indique <b>cluster_top</b> (ID o nombre) para visualizar.</div>"))
                return
            # pairs = [(cid, self.label_map_top[cid]) for cid in sorted(self.label_map_top, key=int)]
            self._render_candidates_table("Clusters TOP disponibles", pairs, limit=listar_max, open=False)

            tid = self._resolve_top_id(cluster_top.strip())
            if not tid:
                display(HTML(f"<div style='color:#c00'>TOP <b>{cluster_top}</b> no encontrado.</div>"))
                return
            top_name = self.label_map_top.get(tid, tid)
            cluster = self.get_cluster(tid)



            display(HTML(
                f"<div style='font-family:sans-serif;margin:6px 0 10px 0;'>"
                f"Nivel: <b>TOP</b> &nbsp;|&nbsp; Cluster: <b>{top_name}</b> (ID: {tid}) "
                f"&nbsp;|&nbsp; Tipo: <b>{self.stuff_titles.get(stuff_type, stuff_type)}</b></div>"
            ))
            fig = self._build_figure(cluster, stuff_type)
            if fig is not None:
                self._show_figure(fig)
            return

        # === SUB ===
        if not cluster_top.strip(): # Para SUB obligamos a elegir primero un TOP (y le mostramos sus opciones)
          pairs = [(cid, self.label_map_top[cid]) for cid in sorted(self.label_map_top, key=int)]
          self._render_candidates_table("Clusters TOP disponibles", pairs, limit=listar_max)
          self._notify("Indicá <b>cluster_top</b> (ID o nombre) para visualizar.", "info")
          return

        tid = self._resolve_top_id(cluster_top.strip())
        if not tid:
          self._notify(f"TOP <b>{cluster_top}</b> no encontrado.", "error")
          return

        sub_ids = self.subclusters_by_top.get(tid, [])
        sub_pairs = [(sid, self.label_map_sub.get(sid, sid)) for sid in sorted(sub_ids, key=int)]
        self._render_candidates_table("Clusters TOP disponibles", pairs, limit=listar_max, open=False)

        if not cluster_sub.strip(): # Si todavía no se eligió SUB, listamos los de ese TOP y salimos
            pairs = [(cid, self.label_map_top[cid]) for cid in sorted(self.label_map_top, key=int)]
            self._render_candidates_table(
                f"Subclusters de TOP {self.label_map_top.get(tid, tid)} (ID {tid})",
                sub_pairs, limit=listar_max
            )
            self._notify("Indicá <b>cluster_sub</b> (ID o nombre) para visualizar.", "info")
            return



        sid = self._resolve_sub_in_top(tid, cluster_sub.strip())
        if not sid:
          self._notify(
              f"El SUB <b>{cluster_sub}</b> no existe dentro del TOP <b>{self.label_map_top.get(tid, tid)}</b> (ID {tid}).",
              "error"
          )
          return


        sub_name = self.label_map_sub.get(sid, sid)
        top_name = self.label_map_top.get(tid, tid)
        cluster = self.get_cluster(sid)
        display(HTML(
            f"<div style='font-family:sans-serif;margin:6px 0 10px 0;'>"
            f"Nivel: <b>SUB</b> &nbsp;|&nbsp; Cluster: <b>{sub_name}</b> (ID: {sid}) "
            f"&nbsp;|&nbsp; TOP: <b>{top_name}</b> (ID: {tid}) "
            f"&nbsp;|&nbsp; Tipo: <b>{self.stuff_titles.get(stuff_type, stuff_type)}</b></div>"
        ))
        fig = self._build_figure(cluster, stuff_type)
        if fig is not None:
            self._show_figure(fig)


    def _display_cluster_table(
        self,
        title: str,
        headers: List[str],
        rows: List[List[Any]],
        link_column: Optional[int] = None,
        link_prefix: Optional[str] = None
    ) -> None:
        """Arma una tabla HTML con fondo blanco y texto negro (legible en tema oscuro), con links a Scholar."""
        html = f"""
        <h3 style='text-align: left; font-family: sans-serif;'>{title}</h3>
        <div style='max-width: 1000px; margin: left; overflow-y: auto; max-height: 600px; background-color: white; border: 1px solid #ccc;'>
        <table style='width: 100%; border-collapse: collapse; font-family: sans-serif; background-color: white; color: black !important;'>
            <thead style='background-color: #e6e6e6; color: black !important;'>
                <tr>
                    {''.join(f"<th style='padding: 10px; text-align: justify; border-bottom: 1px solid #ccc; color: black !important;'>{col}</th>" for col in headers)}
                </tr>
            </thead>
            <tbody>
        """
        for row in rows:
            html += "<tr>"
            for i, col in enumerate(row):
                if link_column is not None and i == link_column:
                    query = str(col).replace(' ', '+')
                    link = f"{link_prefix}{query}"
                    html += f"<td style='padding: 8px; text-align: justify; border-bottom: 1px solid #eee; color: black !important;'><a style='color: #0645AD !important;' href='{link}' target='_blank'>{col}</a></td>"
                else:
                    html += f"<td style='padding: 8px; text-align: justify; border-bottom: 1px solid #eee; color: black !important;'>{col}</td>"
            html += "</tr>"
        html += "</tbody></table></div>"
        display(HTML(html))

    def _show_figure(self, fig: go.Figure) -> None:  #Muestra figuras de Plotly directamente (con fallback HTML si hace falta).
      try:
          pio.show(fig)
      except Exception:
          html = pio.to_html(fig, include_plotlyjs="cdn", full_html=False)
          display(HTML(html))

    def _build_figure(self, cluster_data: Dict[str, Any], stuff_type: str) -> Optional[go.Figure]:
        cid = str(cluster_data.get("name"))
        cluster_name = cluster_data.get("label_real", cluster_data.get("label", cid))
        size_val = int(cluster_data.get("size", 0))
        stuff = (cluster_data.get("stuff", {}) or {}).get(stuff_type, [])

        titles = {
            "Y": "Publicaciones por año",
            "MCP": "Artículos más citados",
            "MRP": "Artículos más representativos",
            "MCAU": "Autores más citados",
        }

        if not stuff:
          if getattr(self, "verbose_notify", False):
              self._notify(f"{cluster_name}: sin datos para <b>{self.stuff_titles.get(stuff_type, stuff_type)}</b>.", "warn")
          return go.Figure().update_layout(title=f"{cluster_name}: sin datos para {stuff_type}")


        if stuff_type == "Y": # ---------- Distribución por año ----------
            stuff = sorted(stuff, key=lambda s: int(s[0])) # asegurar orden cronológico
            labels = [int(s[0]) for s in stuff]
            values = [int(round(s[1])) for s in stuff]
            fig = go.Figure(go.Bar(x=labels, y=values, text=[f"{v}" for v in values], textposition="auto"))
            fig.update_layout(
                title=f"{cluster_name} — {titles.get('Y', 'Año')}",
                xaxis_title="Año", yaxis_title="N° artículos",
                height=max(360, 28*len(labels)),
                margin=dict(l=60, r=20, t=40, b=40),
            )
            return fig

        if stuff_type in ("MCP", "MRP"):    # ---------- Tablas: MCP / MRP ----------
            headers = ["Title", "Author(s)", "Journal (Year)", "In-degree", "Times Cited"]
            rows = []
            for item in stuff: # (title, author, journal, year, cited, indegree, doc_type)
                title = item[0] if len(item) > 0 else ""
                author = item[1] if len(item) > 1 else ""
                journal = item[2] if len(item) > 2 else ""
                year = item[3] if len(item) > 3 else ""
                cited = item[4] if len(item) > 4 else 0
                indegree = item[5] if len(item) > 5 else 0
                rows.append([title, author, f"{journal} ({year})", indegree, cited])

            pretty = "Most Representative Papers" if stuff_type == "MRP" else "Most Cited Papers"
            self._display_cluster_table(
                title=f"{cluster_name} — {pretty} ({len(rows)})",
                headers=headers,
                rows=rows,
                link_column=0,
                link_prefix="https://scholar.google.com/scholar?q="
            )
            return None

        if stuff_type == "MCAU":     # ---------- Tabla: MCAU ----------
            headers = ["Author", "Papers", "Citations"]
            def _to_int(x):  # caster tolerante
              try:
                  return int(float(x))
              except Exception:
                  return 0
            rows = []
            for item in stuff:
                author = item[0] if len(item) > 0 else ""
                citations = _to_int(item[1] if len(item) > 1 else 0)
                papers = _to_int(item[2] if len(item) > 2 else 0)
                rows.append([author, papers, citations])

            self._display_cluster_table(
                title=f"{cluster_name} — Most Cited Authors ({len(rows)})",
                headers=headers,
                rows=rows,
                link_column=0,
                link_prefix="https://scholar.google.com/scholar?q="
            )
            return None
        # ---------- Frecuencias (barras o pie chart) ----------
        if isinstance(stuff[0], (list, tuple)) and len(stuff[0]) >= 2:
          labels = [str(s[0]) for s in stuff]
          values = [float(s[1]) for s in stuff]
          top = sorted(zip(labels, values), key=lambda x: x[1])[-20:]  # top 20 por valor
          labels, values = (list(zip(*top))[0], list(zip(*top))[1]) if top else ([], [])

          if len(labels) <= 6:
              fig = go.Figure(go.Pie(labels=labels, values=values, textinfo="label+percent", hole=0.3))
              fig.update_layout(title=f"{cluster_name} — {self.stuff_titles.get(stuff_type, stuff_type)}")
          else:
              fig = go.Figure(go.Bar(
                  x=values, y=labels, orientation="h",
                  text=[f"{v:.2f}" for v in values], textposition="auto"
              ))
              fig.update_layout(
                  title=f"{cluster_name} ({size_val} artículos) — {self.stuff_titles.get(stuff_type, stuff_type)}",
                  height=max(520, len(labels)*28),
                  margin=dict(l=110, r=20, t=40, b=40),
                  xaxis_title="Frecuencia"
              )
          return fig

        return go.Figure().update_layout(title=f"{cluster_name} — {stuff_type} (formato no reconocido)")

    # ------------------------ HELPERS ------------------------
    def _render_candidates_table(self, title: str, pairs: List[Tuple[str, str]], limit: int = 15, open: bool=True) -> None:
        """Tabla HTML para listar candidatos (TOPs o SUBs) para ayudar al usuario a seleccionar en describe_cluster_params"""
        if not pairs:
            return
        rows = "".join(
            f"<tr><td style='padding:4px 8px'>{i+1}</td>"
            f"<td style='padding:4px 8px'>{name}</td>"
            f"<td style='padding:4px 8px'>{cid}</td></tr>"
            for i, (cid, name) in enumerate(pairs[:limit])
        )
        if open:
          detail_txt = f"<details open style='margin:6px 0'><summary style='cursor:pointer'>"
        else:
          detail_txt = f"<details style='margin:6px 0'><summary style='cursor:pointer'>"
        display(HTML(
          f"{detail_txt}"
          f"{title} (top {min(limit,len(pairs))}/{len(pairs)})</summary>"
          "<table style='border-collapse:collapse;margin-top:6px'>"
          "<thead><tr><th style='text-align:left;padding:4px 8px'>#</th>"
          "<th style='text-align:left;padding:4px 8px'>Nombre</th>"
          "<th style='text-align:left;padding:4px 8px'>ID</th></tr></thead>"
          f"<tbody>{rows}</tbody></table></details>"
          ))



    def _resolve_top_id(self, val) -> Optional[str]:
        """Devuelve el ID de un TOP a partir de un ID o un nombre."""
        if val is None:
            return None
        s = str(val).strip()

        # 1) Si es un ID de TOP existente en el JSON, devolvelo directo.
        n = self.cluster_dict.get(s)
        if n and int(n.get("level", 0)) == 0:
            return s

        # 2) Intentar por nombre en mapas (exacto y normalizado/case-insensitive).
        v_norm = self._normalize_label_capital(s)
        # a) nombre → id directo
        if v_norm in self.cluster_name_to_id:
            return self.cluster_name_to_id[v_norm]
        # b) recorrer label_map_top y comparar case-insensitive
        for cid, name in self.label_map_top.items():
            if name and (name == s or name.lower() == s.lower() or self._normalize_label_capital(name) == v_norm):
                return cid

        # 3) Fallback: recorrer JSON (label_real / label) para TOPs
        for cid, node in self.cluster_dict.items():
            if int(node.get("level", 0)) != 0:
                continue
            for cand in (node.get("label_real"), node.get("label")):
                if not cand:
                    continue
                if (str(cand) == s or str(cand).lower() == s.lower() or
                    self._normalize_label_capital(str(cand)) == v_norm):
                    return str(cid)

        return None


    def _resolve_sub_in_top(self, top_id: str, val) -> Optional[str]:
        """Devuelve el ID de un SUB (dentro del TOP dado) a partir de un ID o nombre."""
        if not top_id or val is None:
            return None
        tid = str(top_id)
        s = str(val).strip()

        subs = set(self.subclusters_by_top.get(tid, []))
        if not subs:
            return None

        # 1) Si ya es un ID y pertenece a ese TOP, devolverlo
        if s in subs:
            return s

        # 2) Intentar por nombre en mapas (exacto y normalizado/case-insensitive)
        s_norm = self._normalize_label_capital(s)
        for sid in subs:
            name = self.label_map_sub.get(sid)
            if name and (name == s or name.lower() == s.lower() or self._normalize_label_capital(name) == s_norm):
                return sid

        # 3) Fallback: recorrer JSON (label_real / label)
        for sid in subs:
            node = self.cluster_dict.get(sid, {})
            for cand in (node.get("label_real"), node.get("label")):
                if not cand:
                    continue
                if (str(cand) == s or str(cand).lower() == s.lower() or
                    self._normalize_label_capital(str(cand)) == s_norm):
                    return sid

        return None


    def _notify(self, msg: str, kind: str = "info") -> None:
        """Muestra mensajes como HTML (más amigable que errores de consola)."""
        colors = {
            "info":   ("#0b5", "#e8f9f0"),   # verde
            "warn":   ("#b80", "#fff6e5"),   # amarillo
            "error":  ("#c00", "#ffeaea"),   # rojo
            "success":("#0a7", "#e9fbf4"),   # verde éxito
        }
        fg, bg = colors.get(kind, colors["info"])
        display(HTML(
            f"<div style='font-family:sans-serif; padding:10px 12px; border:1px solid {fg}; "
            f"border-radius:6px; background:{bg}; color:#111; line-height:1.4'>{msg}</div>"
        ))

    def rename_cluster(
        self,
        level: str,           # "TOP" | "SUB"
        cluster: str,         # ID o nombre del cluster a renombrar
        new_name: str,        # nuevo nombre
        top_id: Optional[str] = None  # opcional: para SUB si pasás nombre ambiguo
    ) -> None:

        level = (level or "").strip().upper()
        if level not in ("TOP", "SUB"):
          self._notify("El parámetro <b>level</b> debe ser 'TOP' o 'SUB'.", "error")
          return

        if not cluster or not cluster.strip():
            self._notify("Indicá un <b>cluster</b> (ID o nombre) para renombrar.", "error")
            return

        if not new_name or not new_name.strip():
            self._notify("Indicá el <b>nuevo nombre</b> (new_name) para renombrar.", "error")
            return

        new_name = new_name.strip()

        # Helper: aplica el cambio y sincroniza estructuras
        def _apply_rename(id_str: str, map_label: dict, map_rev: dict, gdf_nodes: list, lvl_text: str) -> None:
          old = map_label[id_str]
          if old in map_rev:
              del map_rev[old]
          map_label[id_str] = new_name
          map_rev[new_name] = id_str
          # cluster_dict
          if id_str in self.cluster_dict:
              self.cluster_dict[id_str]["label_real"] = new_name
          # GDF
          for n in gdf_nodes:
              if n.get("id") == id_str:
                  n["label"] = new_name
                  break
          self._notify(
              f"<b>Renombrado correcto</b> — Nivel: <b>{lvl_text}</b> · ID: <code>{id_str}</code> "
              f"· <i>{old}</i> → <b>{new_name}</b>", "success"
          )

        if level == "TOP":
            tid = self._resolve_top_id(cluster)
            if not tid:
                self._notify(f"TOP <b>{cluster}</b> no encontrado (usá ID o nombre exacto).", "error")
                return
            _apply_rename(tid, self.label_map_top, self.cluster_name_to_id, self.gdf_nodes_top, "TOP")
            return

        # SUB
        resolved_top = self._resolve_top_id(top_id) if top_id else None

        # Si 'cluster' es ID de SUB
        if cluster in self.label_map_sub:
            sid = cluster
            if resolved_top:
                subs = set(self.subclusters_by_top.get(resolved_top, []))
                if sid not in subs:
                    top_name = self.label_map_top.get(resolved_top, resolved_top)
                    self._notify(
                        f"El SUB <code>{sid}</code> no pertenece al TOP indicado "
                        f"(<b>{top_name}</b>, ID <code>{resolved_top}</code>).", "error"
                    )
                    return
            _apply_rename(sid, self.label_map_sub, self.subcluster_name_to_id, self.gdf_nodes_sub, "SUB")
            return

        # Si 'cluster' es NOMBRE de SUB: buscar ID (limitando por TOP si lo dieron)
        if resolved_top:
            candidates = [sid for sid in self.subclusters_by_top.get(resolved_top, [])
                          if self.label_map_sub.get(sid) == cluster]
        else:
            candidates = [sid for sid, name in self.label_map_sub.items() if name == cluster]

        if not candidates:
            hint = ""
            if not resolved_top:
                hint = " Si el nombre existe en más de un TOP, indicá también <b>top_id</b> (ID o nombre del TOP)."
            self._notify(f"SUB <b>{cluster}</b> no encontrado.{hint}", "error")
            return

        if len(candidates) > 1:
            # listado de coincidencias para ayudar
            items = []
            for sid in candidates:
                owner_top = None
                for tid, subs in self.subclusters_by_top.items():
                    if sid in subs:
                        owner_top = tid
                        break
                items.append(f"<li>SUB ID <code>{sid}</code> en TOP <code>{owner_top}</code> "
                            f"(<b>{self.label_map_top.get(owner_top, owner_top)}</b>)</li>")
            self._notify(
                "El nombre indicado coincide con múltiples SUB en distintos TOP. "
                "Indicá <b>top_id</b> para desambiguar:<ul>" + "".join(items) + "</ul>",
                "warn"
            )
            return

        sid = candidates[0]
        _apply_rename(sid, self.label_map_sub, self.subcluster_name_to_id, self.gdf_nodes_sub)

"""## **Instanciando la clase `TyK`**

Antes de empezar a analizar y visualizar datos, necesitamos **crear nuestra herramienta de trabajo**: la clase `TyK`. Será nuestro tablero de control que usaremos durante todo el análisis.

---

### **¿Qué hace este paso?**
- **Carga** la información de clusters y subclusters desde varios archivos.
- **Guarda** estos datos en memoria para poder explorarlos y graficarlos.
- **Conecta** los nombres de los clusters con sus identificadores numéricos.

---


### **¿Qué debo modificar?**
- Solo el valor de **`PATH`**, que indica la **carpeta donde están guardados los archivos**.  
  Si los archivos están en otra ubicación, se ajusta esta ruta.



"""

PATH = "/content/drive/MyDrive/Drive/Mauri_AR/"

tyk = TyK(
    path_base=PATH, #ESTO ES LO UNICO QUE HAY QUE MODIFICAR
)

# contar cuántos items hay por stuff en cada TOP
for cid, name in tyk.list_clusters(top=True, show=None):
    c = tyk.get_cluster(cid)
    stuff = (c.get("stuff") or {})
    counts = {k: len(v or []) for k, v in stuff.items()}
    print(f"{cid} — {name}:", counts)

import pandas as pd

stuff_types = ["MCP","MRP","MCAU","K","TK","S","S2","J","C","I","R","RJ","A","Y"]
rows = []

for cid, name in tyk.list_clusters(top=True, show=None):   # top=False para SUB

    c = tyk.get_cluster(cid)
    s = (c.get("stuff") or {})
    row = {"id": cid, "name": name, "size": int(c.get("size", 0))}
    for t in stuff_types:
        row[t] = len(s.get(t, []) or [])
    rows.append(row)

df = pd.DataFrame(rows).set_index(["id","name"]).sort_values("MCP", ascending=False)
df

# @title
tyk.plot_map()

tyk.plot_countries_map_global(colorscale="Turbo")

"""Mostrar todos los clusters o subclusters:"""

# @title {"run":"auto"}
level = "TOP"            # @param ["TOP","SUB"]
if level == "TOP":
  tyk.list_clusters()
else:
  tyk.list_clusters(top=False)

"""Mostrar los subclusters de un cluster"""

# @title {"run":"auto"}
top_cluster = "10"  # @param {"type":"string"}
tyk.list_subclusters(top_cluster)

"""## **Visualización de la red de co-ocurrencia**

En este paso vamos a generar un **grafo** que muestra cómo se relacionan entre sí los elementos de un tipo específico (por ejemplo, palabras clave, revistas o autores).

---

### **¿Qué hace este paso?**
- **Filtra** los nodos de la red según el tipo indicado (`node_type`).
- **Elimina** nodos muy pequeños para simplificar la visualización (`min_node_size`).
- **Construye** un grafo en el que:
  - Cada nodo representa un elemento (ej. palabra clave).
  - Cada arista representa la co-ocurrencia con otro elemento.

---

### **Parámetros utilizados**
- **`node_type="K"`** → Visualiza palabras clave (*Keywords*).
  - `"K"` → Palabras clave.
  - `"TK"` → Palabras del título.
  - `"S"` → Categorías temáticas.
  - `"S2"` → "Subject Sub-Categories"
  - `"I"` → "Institutions"
  - `"R"` → "References"
  - `"RJ"` → "Reference Sources"
- **`min_node_size=5`** → Muestra solo elementos con al menos 5 ocurrencias.

---

"""

# @title {"run":"auto"}
node_type = "K"  # @param ["K","TK","S","S2","I","R","RJ"]
max_nodes = 250 # @param {"type": "string"}
tyk.plot_cooc_network_interactive(node_type=node_type, min_node_size=5, max_nodes= max_nodes);

"""## **Visualización del grafo de clusters principales (TOP)**

Muestra un **mapa de relaciones** entre los clusters principales (*TOP*)

---

### **¿Qué hace este paso?**
- **Construye** un grafo donde:
  - Cada nodo es un cluster principal.
  - Las aristas representan conexiones o relaciones entre clusters.
- **Ajusta** el tamaño de los nodos en función de su importancia o tamaño.

---

### **Parámetros utilizados**
- **`layout="circular"`** → Organiza los nodos en un círculo, útil para obtener una vista equilibrada y simétrica de la red.

"""

tyk.plot_clusters_graph_interactive()

"""## **Visualización interactiva de subclusters por TOP**

Esta función permite **explorar gráficamente** todos los subclusters que pertenecen a un cluster principal (**TOP**) específico.  
Es útil para identificar la estructura interna de un TOP y las relaciones entre sus subclusters.

---

### **Instrucciones de uso**
1. **Selecciona** el TOP que deseas analizar:
   - Puedes ingresar **el ID** del TOP (ej: `1`).
   - O **su nombre** exacto tal como aparece en la lista (ej: `"EMPATHY"`).
2. El grafo resultante mostrará:
   - **Nodos** → Cada subcluster del TOP seleccionado.
   - **Conexiones** → Relaciones detectadas entre subclusters.
3. Si no indicas ningún TOP:
   - Se mostrará una **lista de todos los TOPs** disponibles para que elijas.

"""

# @title {"run":"auto"}
top_cluster = "5"  # @param {"type":"string"}
tyk.plot_subclusters_graph_interactive(top_cluster)

"""## **Renombrar un cluster (TOP o SUB)**

Con este comando puedes cambiar el nombre de cualquier **TOP** o **SUB** cluster de forma inmediata.  
Este cambio se aplicará a todas las visualizaciones, tablas y listados, pero **no modifica los archivos originales** en disco.
1. **Selecciona** si es un TOP o SUB cluster.
2. **Indica** el cluster que deseas modificar:
   - Puedes ingresar **el ID** del TOP (ej: `1`).
   - O **su nombre** exacto tal como aparece en la lista (ej: `"EMPATHY"`).
3. Ingresa el **nuevo nombre** del cluster indicado previamente.


"""

# @title {"run":"auto"}
level = "SUB"            # @param ["TOP","SUB"]
cluster = "10"  # @param {"type":"string"}
nuevo_nombre = "PERFORMANCes"  # @param {"type":"string"}

tyk.rename_cluster(level=level, cluster=cluster, new_name=nuevo_nombre)

"""## **Exploración detallada de un cluster o subcluster**

Esta es la función más importante para **examinar en profundidad** la información de un cluster específico, ya sea un **TOP** o un **SUB**.  
Permite visualizar gráficos, tablas y métricas asociadas al tipo de información seleccionado.

---

### **Parámetros principales**
- **`level`** → Nivel de análisis:
  - `"TOP"` → Examina un cluster principal.
  - `"SUB"` → Examina un subcluster que pertenece a un TOP.
- **`cluster_top`** → ID o nombre del TOP que se quiere explorar.
- **`cluster_sub`** → ID o nombre del subcluster (solo si `level="SUB"`).


### **Comportamiento**
- **Si `level="TOP"`**:
  - Sin `cluster_top` → Lista los TOP disponibles.
  - Con `cluster_top` → Muestra figura o tabla del TOP.
- **Si `level="SUB"`**:
  - Requiere `cluster_top`.
  - Sin `cluster_sub` → Lista los subclusters del TOP elegido.
  - Con `cluster_sub` → Muestra figura o tabla del SUB, indicando también a qué TOP pertenece.

---

### **Visualización**
- Muestra siempre un **encabezado descriptivo** con:
  - Nivel.
  - Nombre y ID del cluster.
  - Tipo de información seleccionada.
- El contenido mostrado dependerá del `stuff_type` elegido: puede ser un **gráfico interactivo** o una **tabla con enlaces**.

"""

# @title {"run":"auto"}
cluster_top = "1"        # @param {"type":"string"}
stuff_type = "MRP"         # @param ["K","TK","S","S2","J","C","I","R","RJ","A","MCAU","MCP","MRP","Y"]
tyk.describe_cluster_params("TOP", stuff_type, cluster_top, "")

# @title {"run":"auto"}
cluster_top = "1"        # @param {"type":"string"}
cluster_sub = "1000"         # @param {"type":"string"}
stuff_type = "TK"         # @param ["K","TK","S","S2","J","C","I","R","RJ","A","MCAU","MCP","MRP","Y"]
tyk.describe_cluster_params("SUB", stuff_type, cluster_top, cluster_sub)

#MOSTRAR SIEMPRE SUBCLUSTERS

"""Les dejo el ejemplo original de django
![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABYcAAARKCAIAAACb61hmAAAgAElEQVR4AezdeXgU153vfz2P/8g8mV9+d547k+XGtm4mkzj3ZpvMncxvcmNrEju2EtvCxkMWY8e7HccLpluS2SwwSGADXoAgAcZgDAHZrGKXsUHYZjGYxSwCSey7QEiIRb1VV9X5TfXprq6u7pbUrZa6pX7z6AnVVdVVp15VJKmPvuecHMEfBBBAAAEEEEAAAQQQQAABBBBAIB0COek4KedEAAEEEEAAAQQQQAABBBBAAAEEBKkEDwECCCCAAAIIIIAAAggggAACCKRHgFQiPe6cFQEEEEAAAQQQQAABBBBAAAEESCV4BhBAAAEEEEAAAQQQQAABBBBAID0CpBLpceesCCCAAAIIIIAAAggggAACCCBAKsEzgAACCCCAAAIIIIAAAggggAAC6REglUiPO2dFAAEEEEAAAQQQQAABBBBAAAFSCZ4BBBBAAAEEEEAAAQQQQAABBBBIjwCpRHrcOSsCCCCAAAIIIIAAAggggAACCJBK8AwggAACCCCAAAIIIIAAAggggEB6BEgl0uPOWRFAAAEEEEAAAQQQQAABBBBAgFSCZwABBBBAAAEEEEAAAQQQQAABBNIjQCqRHnfOigACCCCAAAIIIIAAAggggAACpBI8AwgggAACCCCAAAIIIIAAAgggkB4BUon0uHNWBBBAAAEEEEAAAQQQQAABBBAgleAZQAABBBBAAAEEEEAAAQQQQACB9AiQSqTHnbMigAACCCCAAAIIIIAAAggggACpBM8AAggggAACCCCAAAIIIIAAAgikR4BUIj3unBUBBBBAAAEEEEAAAQQQQAABBEgleAYQQAABBBBAAAEEEEAAAQQQQCA9AqQS6XHnrAgggAACCCCAAAIIIIAAAgggQCrBM4AAAggggAACCCCAAAIIIIAAAukRIJVIjztnRQABBBBAAAEEEEAAAQQQQAABUgmeAQQQQAABBBBAAAEEEEAAAQQQSI8AqUR63DkrAggggAACCCCAAAIIIIAAAgiQSvAMIIAAAggggAACCCCAAAIIIIBAegRIJdLjzlkRQAABBBBAAAEEEEAAAQQQQIBUgmcAAQQQQAABBBBAAAEEEEAAAQTSI0AqkR53zooAAggggAACCCCAAAIIIIAAAqQSPAMIIIAAAggggAACCCCAAAII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)
"""